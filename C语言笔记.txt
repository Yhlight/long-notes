//////////////////////////////////////////////////////////////
准备工作（非教程必须）
1.英文语言安装
在输入法中添加英语语言，方便敲写，防止中文字符等问题
2.visual studio工具（简称VS）
前往官网下载visual studio
3.vs组件
C++桌面开发，C++游戏开发（非工作室的不用管）

//////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
阅读顺序
每一个内容都有深浅之分，这里推荐看完每一个内容的浅层内容先
之后再从头开始看，遇到看不懂的就通过浅层内容来判断属于什么内容
跳到那边进行了解，此教程是分内容而不是学习顺序
如果使用学习顺序来编排，那样会很乱，不适合复习
在前面学习中，你会发现printf打印函数会比printf的具体学习早出现
这是因为前面是了解过程，让你学会复制粘贴，还不需要你去学习

//////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
计算机语言，汇编语言，B语言，C语言
C语言国际标准：ANSI C，C11
使用工具：visual studio 2022
计算机初始计数为0，很多语句都是从0开始计算

如何创建一个C语言项目
打开vs，新建项目，选择空项目或者控制台应用
创建成功后，在你的左/右手边会有一个解决方案管理器
选择头文件，右键添加新建项
更改文件为xxx.c（直接更改格式）
cpp文件格式是C++用的

C语言的基础结构
#include <stdio.h> //C语言标准库

int main()
{
   return 0;
}

//////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
编程辅助工具

https://github.com/

https://stackoverflow.com/  //程序员的知乎

https://cplusplus.com/reference/

MSDN(microsoft developer network)

https://zh.cppreference.com/

//////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
原码，反码，补码（简单了解）
数据在内存中的储存方式为补码
而呈现出来的数字则是原码
原码，反码，补码与二进制有关
二进制位中，最左位决定正负
正数的原，反，补码均不变
负数的反码为符号位不变，每一位取反
负数的补码为该数绝对值取反再加1

实例：
85
原码：0000000001010101
反码：0000000001010101
补码：0000000001010101

-85
原码：1000000001010101
反码：1111111110101010
补码：1111111110101011

-144
原码：1000000010010000
反码：1111111101101111
补码：1111111101110000

负数补码的规律是该数绝对值取反再加1
综合-85及-144的补码，可以得到加1的规律为
1111111110101010+0000000000000001=1111111110101011
结尾为0直接变更为1
1111111101101111+0000000000000001=1111111101110000
当结尾为1时，加1会变为2
但二进制仅由0/1组成，无法出现0/1之外的数字
此时要应用逢二进一规则
即本位为2时，向前进一位1，同时本位归零

//////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
基本数据类型
char //字符数据类型
short //短整型
int //整形
long //长整型
long long //更长的整形
float //单精度浮点数
double //双精度浮点数

有无符号
signed 修饰的数据类型有符号
unsigned 修饰的数据类型无符号

%d  整形
%u  无符号整形
%c  字符
%s  字符串
%f  单浮点
%lf 双浮点
%x  16进制打印
%p  指针/地址

字符：仅且一个字符组成并被单引号括起来的字符
'A','c','1','='

字符串：由一个或多个字符组成并被双引号括起来的字符或字符串
字符串的结束标志是转义字符\0
在计算字符串长度时\0作为结束标志，不作为内容
"a","abc"

验证字符串存在\0
#include <stdio.h>

int main()
{

   char arr1[]={"abc"};
   char arr2[]={'a','b','c'};
   printf("%s\n",arr1);
   printf("%s\n",arr2);
   return 0;
}

计算字符串长度 strlen
#include <stdio.h>
#include <string.h>  //需要引用string库

int main()
{
	char arr1[] = { "abc" };
	char arr2[] = { 'a','b','c' };
	printf("%d\n", strlen(arr1));
	printf("%d\n", strlen(arr2));  // 结果为随机数
	return 0;
}

或
#include <stdio.h>
#include <string.h>

int main()
{
    char arr[] = { 'a','b','c' };
    printf("%d\n", strlen(arr));
    printf("%d\n", strlen("abc"));  // 结果为随机数
    return 0;
}

转义字符
例：
打印一个目录
#include <stdio.h>

int main()
{
    printf("c:\code\test.c\n");
    return 0;
}
实际打印结果为c:code  est.c
原因为\t转义字符的存在
解决办法为
    printf("c:\code\\test.c\n");

\0  空字符
\a  引起电脑响铃（蜂鸣）
\b  空格
\f  进纸符
\n  用于换行
\r  回车
\t  水平制表符
\v  垂直制表符
\'  单引号
\"  双引号
\\  \
\ddd ddd表示1-3个八进制数字 如\130
这里打印出来的结果是X
原因是八进制的130转成了十进制，也就是88
再对应ASCII码值

\xdd  表示两个16进制数字
这里打印出来的是0
原因是16进制的130转成了十进制，也就是48
再对应ASCII码值

八进制整数转换10进制整数粗略计算方法
1      3      0
8^2    8^1    8^0
64     24     0
64+24+1=88

十进制整数转换二进制整数粗略计算方法
除得尽，为0，除不尽为1
商      余数    数位    0/1
85/2    42      7       1
42/2    21      6       0
21/2    10      5       1
10/2    5       4       0
5/2     2       3       1
2/2     1       2       0
1/2     0       1       1

//////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
scanf 输入函数
visual studio使用scanf会给出警告
解决方法是添加预处理指令 #define _CRT_SECURE_NO_WARNINGS 1
#define _CRT_SECURE_NO_WARNINGS 1需要在所有代码之前
还可以更改为使用scanf_s（VS独有语句）
这边建议使用scanf

scanf和scanf_s是明显不同的，如果你想使用scanf_s
一定要比较scanf和scanf_s使用的情况
好比如说输入字符串scanf_s需要scanf_s("%s", input, 20);这样的形式
而scanf不需要20

如果你不想经常书写#define _CRT_SECURE_NO_WARNINGS 1
你可以在这个路径下找到newc++file.cpp文件
"D:\VS Studio\Common7\IDE\VC\VCProjectItems\"
打开它并加入#define _CRT_SECURE_NO_WARNINGS 1这句
此后创建文件默认添加此预处理

scanf可以用于两个数的求和
例如
#include <stdio.h>

int main()
{
   int a = 0;
   int b = 0;
   int sum = 0;
   scanf("%d %d",&a,&b);
   sum = a + b;
   printf("sum=%d\n",sum);
   return 0;
}

//////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
printf 打印
printf("我是荧火light")->直接打印内容
printf("%d\n",a)->打印a的值
printf("a=%d\n",a)->打印a=xx,xx为值

你可以通过一些手段实现附加效果
如空格
printf("%d ",a)->打印a的值  \\在%d后面增加一个空格
这样打印一系列数字时会有间隔

//////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
注释
用来解释单行代码或使某部分代码不被编译器读取
// 后面跟的内容不会被编译器读取
在VS中，你可以按CTRL+K,CTRL+C将选中的代码全部注释
注意，这是组合，先按CTRL+K再CTRL+C

取消注释
CTRL+K，CTRL+U

//////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
特殊的代码风格

1.等式互换
if (num == 0) -> if (0 == num)

2.交换律的应用
*(p + 2) -> *(2 + p)

3.等同替换
*(p + 2) -> *(arr + 2)
*(p + 2) -> p[2]
arr[2] -> *(arr + 2)
arr[2] -> 2[arr]  //操作数的互换

//////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
计算机的底层基于二进制
sizeof 计算类型或变量所占空间大小，这里的单位是字节
bit（比特位）
byte（字节）=8bit
kb=1024byte
mb=1024kb
gb=1024mb
tb=1024gb
pb=1024tb

计算各个类型所占空间
#include <stdio.h>

int main()
{
   printf("%d\n",sizeof(char));
   printf("%d\n",sizeof(short));
   printf("%d\n",sizeof(int));
   printf("%d\n",sizeof(long));
   printf("%d\n",sizeof(long long));
   printf("%d\n",sizeof(float));
   printf("%d\n",sizeof(double));
   return 0;
}

在C语言标准中
sizeof(long)>=sizeof(int)

sizeof返回的是无符号整数，是unsigned int类型

//////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
常量： 不能发生改变的值
变量： 可以发生改变的值
{
局部变量：大括号内部定义的变量
全局变量：大括号外部定义的变量
局部变量优先于全局变量
}

变量的作用域和生命周期

作用域：变量的作用范围
简单来说就是变量所在的大括号范围
在这个大括号内变量可以使用
全局变量的作用域是当前文件

如果需要引用其他文件的全局变量
需要使用extern声明变量
int a = 0;（其他文件）

extern int a;

生命周期：变量创建到销毁的时间段
进入生命域生命周期开始，出生命域结束

常量：
1.字面常量
int main()
{
   3.14;
   10;
   "abc";
   'a';
   -10;
}

2.const修饰的变量
const int num = 10;
经const修饰后 num的值无法再更改

3.#define定义的标识符常量
#define MAX 10000

4.枚举常量：可以一一列举的常量
相当于给变量排个序

形式1 先定义类型，后定义变量
enum Sex
{
    MALE,
    FEMALE,
    SECRET,
};

enum Sex s=MALE
Sex是类型，s是变量，
输出s/MALE的结果是0，FEMALE则是1，
你可以把枚举变量当成排序

形式2 同时定义（不推荐）
enum Sex
{
    MALE,
    FEMALE,
    SECRET,
} s=MALE;

形式3 不定义类型，直接定义变量（不推荐）
enum
{
    MALE,
    FEMALE,
    SECRET,
} s=MALE;

指定声明枚举变量
enum Sex
{
    MALE=1,
    FEMALE,
    SECRET,
};
此时从1开始计数，而不是0

//////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
#define
预处理指令，写全局

定义常量
#define MAX 1000

定义宏
宏是一种预处理指令，通常使用#define来定义
#include <stdio.h>

#define ADD(X,Y) X+Y

int main()
{
	printf("%d\n", 4 * ADD(2, 3));
	return 0;
}
宏是参数的替换，这里的ADD(2, 3)先换成2+3
那么结果是4*2+3=11
要解决这问题就需要添加括号
#include <stdio.h>

#define ADD(X,Y) ((X)+(Y))

int main()
{
	printf("%d\n", 4 * ADD(2, 3));
	return 0;
}

//////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
extern 声明外部符号
常用于跨文件使用变量或函数
如：
int a = 0;（其他文件）

extern int a;

//////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
数组
int arr[10]={0,1,2,3,4,5,6,7,8,9};10个元素的数组 //arr只是名字
数组的组成是
类型 名[空间容纳值（可不填）]={元素}
当空间容纳值不填时，根据后方大括号中的元素的个数自动填入
与其他相同，数组从0计数

1.完全初始化数组
int arr[10] = {1,2,3,4,5,6,7,8,9,10};

2.不完全初始化数组
int arr2[5] = {1,2,3};
由于后边的元素的个数少于前方空间容纳值
空余的位置默认为0

例：
1.打印整个数组
#include <stdio.h>

int main()
{
    int arr[10] = { 1,3,5,7,9,11,13,15,17,19 };
    int i = 0;
    while (i < 10)
    {
        printf("%d ", arr[i]);
        i++;
    }
    return 0;
}

一维数组

一维数组的创建和初始化
数组是一组相同类型元素的集合，数组的创建方式为
type_t arr_name [const_n];
type_t 指数组的元素类型
const_n 是一个常量表达式，指定数组的大小

数组创建的实例
1.
int arr[10];
char ch[11];

2.
int arr[10] = {1,2,3,4,5,6,7,8,9,10};

3.
int arr[10] = {1,2,3,4,5};

4.
int arr[] = {1,2,3,4,5,6,7,8,9,10};

5.
char ch[] = { 'bit','i','t' };

6.
char ch[] = "bit";
这一种除了'b','i','t'外，还会有一个'\0'，当成字符串来理解就好了

数组的使用
数组的使用需要下标引用操作符[]
数组的下标是从0开始计数，而不是从1开始
#include <stdio.h>

int main()
{
	int arr[10] = { 5 };
	arr[4] = 5;
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		printf("%d ", arr[i]);
	}
	return 0;
}
如上述代码，arr[4] = 5;就是一个使用数组的实例
上述代码可以进行优化，这些优化在后续教程中会出现且使用
如下：
#include <stdio.h>

int main()
{
	int arr[10] = { 5 };
	arr[4] = 5;
	int i = 0;
	int size = sizeof(arr) / sizeof(arr[0]);
	for (i = 0; i < size; i++)
	{
		printf("%d ", arr[i]);
	}
	return 0;
}
int size = sizeof(arr) / sizeof(arr[0]);
sizeof(arr)是计算整个数组所占用大小，sizeof(arr[0])是计算第一个元素的大小
两者相除可以计算出数组元素的个数，以此决定循环进行的条件 

一维数组在内存中的存储
#include <stdio.h>

int main()
{
	int arr[10] = { 5 };
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		printf("&arr[%d] = %p\n", i, &arr[i]);
	}
	return 0;
}
这里的打印结果是数组各元素的地址，地址使用16进制
如果你有认真看过上述结果的地址，你会发现它们的地址末尾总是相隔4
这是因为一维数组在内存中是连续存放的，而间隔与类型的空间大小有关
这里是int类型，占用4个字节，所以地址的差异为4个字节
同时，你会发现地址逐渐变高，而不是无规则

因而上述可以得出一些结论
1.一维数组在内存中是连续存放的
2.随着数组下标的增长，地址是由低到高变化的

由初位元素的地址推出后续下标元素
#include <stdio.h>

int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int* p = arr;  //数组名是数组首元素的地址
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		printf("%d ", *p);
		p++;
	}
	return 0;
}
正因为一维数组在内存中是连续存放的
上述仅仅是通过指针的解引用便能够求得整个数组的元素
想要了解p++，可以去看后续的指针

二维数组
与一维数组不同，二维数组不仅仅只有行，还包括列
行和列也是从0开始计数

二维数组的创建
int arr[3][4];
[3]是数组的行，[4]是数组的列
上述的表现效果为三行四列，如下所示
[][][][]
[][][][]
[][][][]

二维数组的初始化
1.
int arr[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 };
结果：
{1,2,3,4}
{5,6,7,8}
{9,10,11,12}

2.
int arr[3][4] = { 1,2,3,4,5,6,7 };
结果：
{1,2,3,4}
{5,6,7,0}
{0,0,0,0}

3.
int arr[3][4] = { {1,2},{5,6},{7,8} };
结果：
{1,2,0,0}
{5,6,0,0}
{7,8,0,0}
这一种是将二维数组视为了一维数组，对每一行进行了元素的手动填充

4.
int arr[][4] = { {1,2},{5,6},{7,8} };
二维数组行可以省略，列不得省略

二维数组的使用
#include <stdio.h>

int main()
{
	int arr[][4] = { {1,2},{5,6},{7,8} };
	int i = 0;
	int j = 0;
	for (i = 0; i < 3; i++)
	{
		for (j = 0; j < 4; j++)
		{
			printf("%d ", arr[i][j]);
		}
		printf("\n");
	}
	return 0;
}

二维数组在内存中的存储
#include <stdio.h>

int main()
{
	int arr[][4] = { {1,2},{5,6},{7,8} };
	int i = 0;
	int j = 0;
	for (i = 0; i < 3; i++)
	{
		for (j = 0; j < 4; j++)
		{
			printf("&arr[%d][%d]=%p\n", i, j, &arr[i][j]);
		}
	}
	return 0;
}
二维数组在内容中也是连续存放的
二维数组这种连续存放是特别的
不限于行内部的连续，还有换行的连续

由初位元素的地址推出后续下标元素
#include <stdio.h>

int main()
{
	int arr[][4] = { {1,2},{5,6},{7,8} };
	int i = 0;
	int j = 0;
	int* p = &arr[0][0];
	for (i = 0; i < 12; i++)
	{
		printf("%d ", *p);
		p++;
	}
	return 0;
}

加深二维数组的理解
arr[0]           arr[1]
[]  []  []  []   []  []  []  []
0,1 0,2 0,3 0,4  1,1 1,2 1,3 1,4

arr[0][0]        arr[1][0]
arr[0][1]        arr[1][1]
arr[0][2]        arr[1][2]
arr[0][3]        arr[1][3]

若我们有仔细观察，你会发现第一行是arr[0]+[0/1/2/3]
第二行则是arr[1]+[0/1/2/3]，如果我们将每一行都视为一维数组
你会发现，arr[0]作为了一维数组的数组名
arr[0]+[0/1/2/3]可以访问其中的每一个元素

验证数组名是数组首元素的地址
#include <stdio.h>

int main()
{
	int arr[10] = { 0 };
	printf("%p\n", &arr[0]);
	printf("%p\n", arr);
	return 0;
}
数组名是数组首元素的地址这个结论有两个例外
1.sizeof(数组名) - 计算的是整个数组的大小，单位是字节
2.&数组名 - 取得是整个数组的地址

数组作为函数参数
数组作为函数传参时，形参可以写成两种形式
1.数组形式
void test(int arr[])
{

}

int main()
{
	int arr[] = { 1,2,3,4,5 };
	test(arr);
	return 0;
}

2.指针形式
void test(int* arr)
{

}

int main()
{
	int arr[] = { 1,2,3,4,5 };
	test(arr);
	return 0;
}

数组作为函数参数实例
1.冒泡排序
#include <stdio.h>

void bubble_sort(int arr[], int size)
{
	int i = 0;
	for (i = 0; i < size - 1; i++)
	{
		int j = 0;
		for (j = 0; j < size - 1 - i; j++)
		{
			if (arr[j] > arr[j + 1])
			{
				int tmp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = tmp;
			}
		}
	}
}

int main()
{
	int arr[] = { 9,8,7,6,5,4,3,2,1,0 };
	int size = sizeof(arr) / sizeof(arr[0]);
	bubble_sort(arr, size);
	int i = 0;
	for (i = 0; i < size; i++)
	{
		printf("%d ", arr[i]);
	}
	return 0;
}

数组的综合练习
1.
实现函数zero()，初始化数组全为0
实现printf()，打印数组每一个元素
实现reverse()，函数完成数组元素的逆置
#include <stdio.h>

void zero(int* arr, int size, int i)
{
	while (i < size)
	{
		arr[i] = 0;
		i++;
	}
}

void print(int* arr, int size, int i)
{
	if (i < size)
	{
		printf("%d ", arr[i]);
		print(arr, size, i + 1);
	}
}

void reverse(int* arr, int size, int i)
{
	int left = 0;
	int right = size - 1;
	int tmp = 0;
	for (i = 0; left < right; i++)
	{
		tmp = arr[left];
		arr[left] = arr[right];
		arr[right] = tmp;
		left++;
		right--;
	}
}

int main()
{
	int i = 0;
	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
	int size = sizeof(arr) / sizeof(arr[0]);
	reverse(arr, size, i);
	print(arr, size, i);
	printf("\n");
	zero(arr, size, i);
	print(arr, size, i);
	return 0;
}
这个是我自己的代码，有一些小地方不是很好，下面是老师的
#include <stdio.h>

void init(int arr[], int sz)
{
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		arr[i] = 0;
	}
}
void print(int arr[], int sz)
{
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%d ", arr[i]);
	}
	printf("\n");
}

void reverse(int arr[], int sz)
{
	int left = 0;
	int right = sz - 1;
	while (left < right)
	{
		int tmp = arr[left];
		arr[left] = arr[right];
		arr[right] = tmp;
		left++;
		right--;
	}
}

int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	print(arr, sz);
	reverse(arr, sz);
	print(arr, sz);
	init(arr, sz);
	print(arr, sz);
	return 0;
}

2.交换两个等大的数组
#include <stdio.h>

int main()
{
	int i = 0;
	int arr1[] = { 1,3,5,7,9 };
	int arr2[] = { 2,4,6,8,10 };
	int size = sizeof(arr1) / sizeof(arr1[0]);
	for (i = 0; i < size; i++)
	{
		int tmp = arr1[i];
		arr1[i] = arr2[i];
		arr2[i] = tmp;
	}
	return 0;
}

3.三子棋
此项目需要game.h，game.c，自行创建
game.h
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define ROW 3
#define COL 3

void InitBoard(char board[ROW][COL], int row, int col);

void DispalyBroad(char board[ROW][COL], int row, int col);

void PlayerMove(char board[ROW][COL], int row, int col);

void ComputerMove(char board[ROW][COL], int row, int col);

----------------------------------------------------------------------------
game.c
#include "game.h"

void InitBoard(char board[ROW][COL], int row, int col)
{
	int i = 0;
	int j = 0;
	for (i = 0; i < row; i++)
	{
		for (j = 0; j < col; j++)
		{
			board[i][j] = ' ';
		}
	}
}

//这一段代码是仅限于3x3的，仅供参考
//void DispalyBroad(char board[ROW][COL], int row, int col)
//{
//	int i = 0;
//	for (i = 0; i < row; i++)
//	{
//		printf(" %c | %c | %c \n", board[i][0], board[i][1], board[i][2]);
//		if (i < row - 1)
//		{
//			printf("---|---|---\n");
//		}
//	}
//}

void DispalyBroad(char board[ROW][COL], int row, int col)
{
	int i = 0;
	for (i = 0; i < row; i++)
	{
		int j = 0;
		for (j = 0; j < col; j++)
		{
			printf(" %c ", board[i][j]);
			if (j < col - 1)
			{
				printf("|");
			}
		}
		printf("\n");
		if (i < row - 1)
		{
			int j = 0;
			for (j = 0; j < col; j++)
			{
				printf("---");
				if (j < col - 1)
				{
					printf("|");
				}
			}
			printf("\n");
		}
	}
}

void PlayerMove(char board[ROW][COL], int row, int col)
{
	int x = 0;
	int y = 0;
	printf("玩家走:>\n");
	while (1)
	{
		printf("请输入下棋的坐标:>");
		scanf("%d %d", &x, &y);
		if (x >= 1 && x <= row && y >= 1 && y <= col)
		{
			if (board[x - 1][y - 1] == ' ')
			{
				board[x - 1][y - 1] = '&';
				break;
			}
			else
			{
				printf("位置被占用，请重新输入\n");
			}
		}
		else
		{
			printf("坐标错误，请检查是否在阈值之内\n");
			printf("请重新输入");
		}
	}
}

void ComputerMove(char board[ROW][COL], int row, int col)
{
	printf("电脑走:>\n");
	while (1)
	{
		int x = rand() % row;
		int y = rand() % col;
		if (board[x][y] == ' ')
		{
			board[x][y] = '#';
			break;
		}
	}
}

int IsFull(char board[ROW][COL], int row, int col)
{
	int i = 0;
	int j = 0;
	for (i = 0; i < row; i++)
	{
		for (j = 0; j < col; j++)
		{
			if (board[i][j] == ' ')
			{
				return 0;
			}
		}
	}
	return 1;
}

char IsWin(char board[ROW][COL], int row, int col)
{
	int i = 0;
	for (i = 0; i < row; i++)
	{
		if (board[i][0] == board[i][1] && board[i][1] == board[i][2] && board[i][1] != ' ')
		{
			return board[i][1];
		}
	}
	for (i = 0; i < col; i++)
	{
		if (board[0][i] == board[1][i] && board[1][i] == board[2][i] && board[1][i] != ' ')
		{
			return board[1][i];
		}
	}
	if (board[0][0] == board[1][1] && board[1][1] == board[2][2] && board[1][1] != ' ')
	{
		return board[1][1];
	}
	if (board[0][2] == board[1][1] && board[1][1] == board[2][0] && board[1][1] != ' ')
	{
		return board[1][1];
	}

	int ret = IsFull(board, row, col);
	if (ret == 1)
	{
		return 'Q';
	}
	return 'C';
}

----------------------------------------------------------------------------
test.c
#include "game.h"

void menu()
{
	printf("xxxxxxxxxxxxxxxxxxxxxxxxxx\n");
	printf("----------1.play----------\n");
	printf("----------2.eixt----------\n");
	printf("xxxxxxxxxxxxxxxxxxxxxxxxxx\n");
}

void game()
{
	char board[ROW][COL];
	InitBoard(board, ROW, COL);
	DispalyBroad(board, ROW, COL);
	char ret = 0;
	while (1)
	{
		PlayerMove(board, ROW, COL);
		DispalyBroad(board, ROW, COL);
		ret = IsWin(board, ROW, COL);
		if (ret != 'C')
		{
			break;
		}
		ComputerMove(board, ROW, COL);
		DispalyBroad(board, ROW, COL);
		ret = IsWin(board, ROW, COL);
		if (ret != 'C')
		{
			break;
		}
	}
	if (ret == '&')
	{
		printf("玩家赢\n");
	}
	else if (ret == '#')
	{
		printf("电脑赢\n");
	}
	else
	{
		printf("平局\n");
	}
	DispalyBroad(board, ROW, COL);
}

int main()
{
	int input = 0;
	srand((unsigned int)time(NULL));
	do
	{
		menu();
		printf("请选择:>");
		scanf("%d", &input);
		switch (input)
		{
		case 1:
			game();
			break;
		case 2:
			printf("退出游戏\n");
			return 0;
		default:
			printf("选择错误，重新选择\n");
			break;
		}

	} while (input);
		
	return 0;
}

4.简化版扫雷
此项目需要game.h，game.c，自行创建
game.h
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MINECOUNT 10

#define ROW 9
#define COL 9

#define ROWS ROW+2
#define COLS COL+2

void InitBoard(char board[ROWS][COLS], int rows, int cols, char set);

void DisplayBoard(char board[ROWS][COLS], int row, int col);

void SetMine(char mine[ROWS][COLS], int row, int col);

void FindMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);

----------------------------------------------------------------------------
game.c
#include "game.h"

void InitBoard(char board[ROWS][COLS], int rows, int cols, char set)
{
	int i = 0;
	int j = 0;
	for (i = 0; i < rows; i++)
	{
		for (j = 0; j < cols; j++)
		{
			board[i][j] = set;
		}
	}
}

void DisplayBoard(char board[ROWS][COLS], int row, int col)
{
	int i = 0;
	int j = 0;
	printf("---------扫雷游戏-----------\n");
	for (i = 0; i <= col; i++)
	{
		printf("%d ", i);
	}
	printf("\n");
	for (i = 1; i <= row; i++)
	{
		printf("%d ", i);
		for (j = 1; j <= col; j++)
		{
			printf("%c ", board[i][j]);
		}
		printf("\n");
	}
	printf("---------扫雷游戏-----------\n");
}


void SetMine(char mine[ROWS][COLS], int row, int col)
{
	int count = MINECOUNT;
	while (count)
	{
		int x = rand() % row + 1;
		int y = rand() % col + 1;
		if (mine[x][y] == '0')
		{
			mine[x][y] = '1';
			count--;
		}
	}
}

static int get_mine_count(char mine[ROWS][COLS], int x, int y)
{
	return mine[x - 1][y] +
		mine[x - 1][y - 1] +
		mine[x][y - 1] +
		mine[x + 1][y - 1] +
		mine[x + 1][y] +
		mine[x + 1][y + 1] +
		mine[x][y + 1] +
		mine[x - 1][y + 1] - 8 * '0';
}

void FindMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)
{
	int x = 0;
	int y = 0;
	int win = 0;
	while (win < row * col - MINECOUNT)
	{
		printf("请输入要排查的坐标:>");
		scanf("%d%d", &x, &y);
		if (x >= 1 && x <= row && y >= 1 && y <= col)
		{
			if (mine[x][y] == '1')
			{
				printf("很遗憾，你被炸死了\n");
				DisplayBoard(mine, row, col);
				break;
			}
			else
			{
				int count = get_mine_count(mine, x, y);
				show[x][y] = count + '0';
				DisplayBoard(show, row, col);
				win++;
			}
		}
		else
		{
			printf("坐标不合法，请重新输入\n");
		}
	}
	if (win == row * col - MINECOUNT)
	{
		printf("恭喜你，排雷成功\n");
		DisplayBoard(mine, row, col);
	}
}

----------------------------------------------------------------------------
test.c
#include "game.h"

void menu()
{
	printf("******************************\n");
	printf("******    1. play      *******\n");
	printf("******    0. exit      *******\n");
	printf("******************************\n");
}

void game()
{
	char mine[ROWS][COLS] = { 0 };
	char show[ROWS][COLS] = { 0 };
	InitBoard(mine, ROWS, COLS, '0');
	InitBoard(show, ROWS, COLS, '*');
	DisplayBoard(show, ROW, COL);
	SetMine(mine, ROW, COL);
	FindMine(mine, show, ROW, COL);
}

int main()
{
	int input = 0;
	srand((unsigned int)time(NULL));

	do
	{
		menu();
		printf("请选择:>");
		scanf("%d", &input);
		switch (input)
		{
		case 1:
			game();
			break;
		case 0:
			printf("退出游戏\n");
			break;
		default:
			printf("选择错误，重新选择\n");
			break;
		}
	} while (input);

	return 0;
}

经过改动的简化版扫雷
此项目需要game.h，game.c，自行创建

//////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
选择语句

关键词 if,else,switch,if else

两种使用形式
直接式
   int input = 0;
   if  (input == 0) //==表示等于
       printf("");
   else
       printf("");

嵌套式
   int input = 0;
   if  (input == 0) //==表示等于
   {
       printf("");
   }
   else
   {
       printf("");
    }

多分支选择
   if (表达式1)
   {
       语句1;
   }
   else if (表达式2)
   {
        语句2;
   }
   else
   {
        语句3;
   }

在多分支选择中 有可能会出现中间值
按照日常使用 我们会下意识使用
d <= xx <k
这种表达是不得当的
当xx大于k时，此表达式不使用
正确表达应该是
xx>=d && xx<k  //&& 并

选择语句的就近原则
#include <stdio.h>

int main()
{
   int a = 0;
   int b = 0;
   if (a == 1)
      if (b == 2)
          printf("hehe\n");
   else
          printf("haha");
   return 0;
}
这里的结果是空白
原因在于第一个if a=1不满足
else就第二个if近，else属于第二个if的
而第二个if又是第一个if的分支
但是第一个if压根没满足，直接跳过了
第二个if压根不会进行

对此嵌套式是最推荐的，条理清晰
#include <stdio.h>

int main()
{
   int a = 0;
   int b = 0;
   if (a == 1)
   {
       if (b == 2)
       {
           printf("hehe\n");

       }
       else
       {
           printf("haha");
        }
    }
   return 0;
}

值得一提，使用嵌套式可以忽略就近原则
else可以对应第一个if，如
#include <stdio.h>

int main()
{
   int a = 0;
   int b = 0;
   if (a == 1)
   {
       if (b == 2)
       {
           printf("hehe\n");

       }
    }
    else
    {
           printf("haha");
     }
   return 0;
}

switch
用于多分支情况，可以嵌套使用
基本式->switch(整形表达式) //注意是整形
        {
        }
如果使用字符，需要用ASCII值
例：
#include <stdio.h>

int main()
{
	int day = 0;
	scanf("%d", &day);
	switch (day)
	{
	case 1:
		printf("星期一\n");
        break;
	case 2:
		printf("星期二\n");
        break;
	case 3:
		printf("星期三\n");
        break;
	case 4:
		printf("星期四\n");
        break;
	case 5:
		printf("星期五\n");
        break;
	case 6:
		printf("星期六\n");
        break;
	case 7:
		printf("星期日\n");
        break;
	}
	return 0;
}
case是入口，break是出口，只有case的情况下，代码会一直进行
你输入1，会把一周都打印出来，需要用break跳出代码才能实现分支

多分支指向同一结果
如果需要表达x-(x+y)的结果均为同一个，可以这样表达
#include <stdio.h>

int main()
{
	int day = 0;
	scanf("%d", &day);
	switch (day)
	{
	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
		printf("工作日\n");
		break;
	case 6:
	case 7:
		printf("休息日\n");
		break;
	default:
		printf("超越最大值，无效\n");
        break;
	}
	return 0;
}

default 默认语句
给予分支之外或者错误值反馈

选择语句综合练习
1.任意三个整数从大到小排序
#include <stdio.h>

int main()
{
	int a = 0;
	int b = 0;
	int c = 0;
	scanf("%d %d %d", &a, &b, &c);
	if (a < b)
	{
		int tmp = a;
		a = b;
		b = tmp;
	}
	if (a < c)
	{
		int tmp = a;
		a = c;
		c = tmp;
	}
	if (b < c)
	{
		int tmp = b;
		b = c;
		c = tmp;
	}
	printf("%d %d %d\n", a, b, c);
	return 0;
}

//////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
循环语句

关键词 while,for,do while,goto

例：
#include <stdio.h>

int main()
{
    int i = 0;
    while (i <= 100)
    {
        printf("继续行程：%d\n",i);
        i++;  //i++表示i的赋值加1 i=x+1
    }
    return 0;
}

while循环中的break，continue
break 用于永久终止循环
#include <stdio.h>

int main()
{
	int i = 1;
	while (i <= 10)
	{
		if (i == 5)
			break;
		printf("%d ", i);
		i++;
	}
	return 0;
}
上述打印结果是1 2 3 4，说明break直接结束了循环

continue 跳过本次循环中continue后面的代码，直接进入判断部分
#include <stdio.h>

int main()
{
	int i = 1;
	while (i <= 10)
	{
		if (i == 5)
			continue;
		printf("%d ", i);
		i++;
	}
	return 0;
}
上述的打印结果是1 2 3 4，和break不同
continue并没有直接终止循环，而是进入死循环
原因在于continue是跳过自身后面的代码，直接进入判断部分
而i未达到10，循环未结束，程序再次回到了while继续进行循环


for循环
for(表达式1;表达式2;表达式3)
   循环语句;

在了解for之前，先从while迁移
int main()
{
	int i = 1;  //初始化
	while (i <= 10)  //判断部分
	{
		printf("%d ", i);
		i++;  //调整部分
	}
	return 0;
}
如上所见，while有三部分主体
而for循环中，三者集中于一个位置
表达式1，2，3分别对应初始化，判断部分，调整部分
例：
打印1-10
#include <stdio.h>

int main()
{
	int i = 0;
	for (i = 1; i <= 10; i++)
	{
		printf("%d", i);
	}
	return 0;
}

同while循环，for循环中同样有break，continue
for循环中的break
#include <stdio.h>

int main()
{
	int i = 0;
	for (i = 1; i <= 10; i++)
	{
		if (i == 5)
			break;
		printf("%d ", i);
	}
	return 0;
}
同while循环，break永远跳出循环

for循环中的continue
#include <stdio.h>

int main()
{
	int i = 0;
	for (i = 1; i <= 10; i++)
	{
		if (i == 5)
			continue;
		printf("%d ", i);
	}
	return 0;
}
for循环中continue仍是跳过本次循环中continue后面的代码
与while循环不同，for循环打印的结果是1 2 3 4 6 7 8 9 10
这是因为continue跳过代码后，仍能够进入调整部分
而不同于上述while循环中跳过了调整部分i++

一些for循环控制变量建议（仅是建议）
1.不可在for循环体内修改循环变量，以免出现循环失控
实例：
#include <stdio.h>

int main()
{
	int i = 0;
	for (i = 1; i <= 10; i++)
	{
		printf("%d ", i);
		i = 5;
	}
	return 0;
}
上述代码会发生打印6的死循环，原因在于i=5阻断循环的进行
i的值进入循环后会被更改为5，此时未满足结束条件，回到循环进行i++增加1
程序再将6打印出来，然后再被更改值，以此循环

2.建议for循环控制变量的取值采用“前闭后开区间（左闭右开）”写法
#include <stdio.h>

int main()
{
	int arr[10] = { 0 };
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		printf("%d ", arr[i]);
	}
	return 0;
}
上述代码中i < 10这种形式属于左闭右开写法
要实现同样效果可以写i <= 9，这种是左右均闭合
实际应用上i < 10这种风格其实更好更推荐
但仅是建议，i <= 9同样可行

for循环变种
1.判断部分的省略
#include <stdio.h>

int main()
{
	for (; ;)
	{
		printf("yh");
	}
	return 0;
}
若判断部分省略，判断部分恒为真
这种省略需要在特别熟悉的情况才可以使用
就像如下
#include <stdio.h>

int main()
{
	int i = 0;
	int j = 0;
	for (i = 0; i < 3; i++)
	{
		for (j = 0; j < 3; j++)
		{
			printf("yh\n");
		}
	}
	return 0;
}
上述打印结果是9个yh，若是将i=0和j=0省略
打印结果是3个yh，原因在于j的重置
从不省略的情况分析，i每循环一次，j会循环三次
j=0的存在使得i每一次循环，j都能进行三次循环
而省略的情况，i=0时已经跑完了j的三次循环
当i=1时，j没有被重置为0，这个时候j是满足状态，j循环不进行
直至i循环结束

2.多变量循环
#include <stdio.h>

int main()
{
	int x, y;
	for (x = 0, y = 0; x < 2 && y < 5; x + y, y++)
	{
		printf("yh\n");
	}
	return 0;
}
在C语言语法中，支持多变量的循环

do...while()循环
while循环是先判断后执行的循环
而do...while循环是先执行后判断的循环

do语句的特点：循环至少会进行一次

do语句的语法
do
	循环语句;
while(表达式)
例：
打印1-10的数字
#include <stdio.h>

int main()
{
	int i = 1;
	do
	{
		printf("%d ",i);
		i++;
	} while (i <= 10);
	return 0;
}

do...while()循环中的break，continue
#include <stdio.h>

int main()
{
	int i = 1;
	do
	{
		if (i == 5)
		{
			break;  //continue;
		}
		printf("%d ",i);
		i++;
	} while (i <= 10);
	return 0;
}
上述代码的结果和while相同

goto语句
goto语句可以用来跳转到某一处
C语言中提供了可以随意滥用的goto语句和标记跳转的标号
实践中没必要goto语句，而且goto语句本身有些问题
#include <stdio.h>

int main()
{
flag:
	printf("yhlight\n");
	printf("yinghuolight\n");

	goto flag;
	return 0;
}
上述的代码是专门演示而弄成的死循环
主要用来说明goto的作用
goto滥用很容易打乱程序的正常运行
正常情况下不要使用goto，不要使用goto
goto使用场景是深层嵌套，好比如说跳出三层for循环
三层for循环中，break仅能跳出一层循环，但goto可以全部跳出
goto跳转范围是有限的，仅是一个函数

1.书写一个关机程序
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    char input[20] = { 0 };
	system("shutdown -s -t 60");
	//system执行系统命令
    //shutdown：用于关闭或重启计算机的命令
    //-s：指定计算机关闭
    //-t 60：指定在关闭之前的延迟时间，以秒为单位
    //需要引用stdlib.h头文件
again:
    printf("您的电脑将会在一分钟内关机\n");
    printf("若要取消关机请输入\"我是**\"\n");
    scanf("%s", input);
    if (strcmp(input, "我是**") == 0)
    {
        system("shutdown -a");  //取消关机
    }
    else
    {
        goto again;
    }
    return 0;
}

有关循环的综合练习
1.打印1-100之间所有3的倍数的数
#include <stdio.h>

int main()
{
	int a = 0;
	for (a = 0; a < 100; a++)
	{
		if (a % 3 == 0)
		{
			printf("%d ", a);
		}
	}
	return 0;
}

2.打印1000-2000之间的闰年
#include <stdio.h>

int main()
{
	int i = 1000;
	while (i <= 2000)
	{
		if (i % 4 == 0)
		{
			if (i % 100 != 0)
			{
				printf("%d ", i);
			}
		}

		if (i % 400 == 0)
		{
			printf("%d ", i);
		}
		i++;
	}
	return 0;
}

形式二
#include <stdio.h>

int main()
{
	int i = 1000;
	while (i <= 2000)
	{
		if (((i % 4 == 0) && (i % 100 != 0)) || (i % 400 == 0))
		{
			printf("%d ", i);
		}
		i++;
	}
	return 0;
}

3.打印100-200之间的质数（素数）
#include <stdio.h>

int main()
{
	int i = 0;
	for (i = 100; i <= 200; i++)
	{
		int j = 0;
		for (j = 2; j < i; j++)
		{
			if (i % j == 0)
			{
				break;
			}
		}
		if (i == j)
		{
			printf("%d ", i);
		}
	}
	return 0;
}

方法二
#include <stdio.h>

int main()
{
	int i = 0;
	for (i = 100; i <= 200; i++)
	//如需优化，可以更改为for (i = 101; i <= 200; i+=2)
	{
		int j = 0;
		int flag = 1;  //假设i就是素数
		for (j = 2; j < i; j++)
		//j < i可以更换j <= sqrt(i)
		//sqrt开平方函数，需要引用math.h头文件
		{
			if (i % j == 0)
			{
				flag = 0;  //不是素数
				break;
			}
		}
		if (flag == 1)
		{
			printf("%d ", i);  //素数
		}
	}
	return 0;
}

4.求10个整数中的最大值
#include <stdio.h>

int main()
{
	int arr[10] = { 35,23,46,24,76,243,56,223,14,234 };
	int max = arr[0];  //解决全负数时出现最大值为0的问题
	int i = 0;
	for (i = 0; i <= 10; i++)
	{
		if (arr[i] > max)
		{
			max = arr[i];
		}
	}
	printf("%d", max);
	return 0;
}

5.通过程序，输出1到100的所有整数中出现的数字9的个数
#include <stdio.h>

int main()
{
	int a = 0;
	int count = 0;
	for (a = 1; a <= 100; a++)
	{
		if (a % 10 == 9)
			count++;
		if (a / 10 == 9)
			count++;
	}
	printf("%d", count);
	return 0;
}

6.打印9*9乘法表
#include <stdio.h>

int main()
{
	int n = 0;
	for (n = 1; n <= 9; n++)
	{
		int j = 0;
		for (j = 1; j <= n; j++)
		{
			printf("%d*%d=%-2d ", n, j, n * j);
		}
		printf("%c", '\n');
	}
	return 0;
}
%-2d 2d的意思是打印两位，-2是左对齐
这里的解释是不够合理的，建议自行理解

7.求两个数的最大公约数
常规法
#include <stdio.h>

int main()
{
	int a = 0;
	int b = 0;
	scanf("%d %d", &a, &b);
	int max = 0;
	if (b < a)
	{
		max = b;
	}
	else
	{
		max = a;
	}
	while (1)
	{
		if (a % max == 0 && b % max == 0)
		{
			printf("%d", max);
			break;
		}
		max--;
	}
	return 0;
}

辗转相除法
#include <stdio.h>

int main()
{
    int a = 0;
    int b = 0;
    scanf("%d %d", &a, &b);

    if (b == 0)
	{
        printf("%d\n", a);
        return 0;
    }

    while (b != 0)
    {
        int t = b;
        b = a % b;
        a = t;
    }
    
    printf("%d\n", a);
    return 0;
}

8.求n的阶乘
#include <stdio.h>

int main()
{
    int i = 0;
    int n = 0;
    int ret = 1;
    scanf("%d", &n);
    for (i = 1; i <= n; i++)
    {
        ret = ret * i;
    }
    printf("%d\n", ret);
    return 0;
}

9.求1-10的阶乘之和
单循环方法
#include <stdio.h>

int main()
{
	int i = 0;
	int ret = 1;
	int sum = 0;
	for (i = 1; i <= 10; i++)
	{
		ret = ret * i;
		sum = sum + ret;
	}
	printf("%d", sum);
	return 0;
}

双循环方法
#include <stdio.h>

int main()
{
	int i = 0;
	int n = 0;
	int ret = 1;
	int sum = 0;
	for (i = 1; i <= 10; i++)
	{
		for (n = 1; n <= 10; n++);
		{
			ret = ret * i;
		}
		sum = sum + ret;
	}
	printf("%d", sum);
	return 0;
}

10.求1/1-1/2......-1/100
#include <stdio.h>

int main()
{
	int i = 0;
	double sum = 0.0;
	for (i = 1; i <= 100; i++)
	{
		if (i % 2 == 0)
			sum -= 1.0 / i;
		else
			sum += 1.0 / i;
	}
	printf("%lf", sum);
	return 0;
}

形式2
#include <stdio.h>

int main()
{
	int i = 0;
	double sum = 0.0;
	int flag = 1;
	for (i = 1; i <= 100; i++)
	{
		sum += flag * 1.0 / i;
		flag = -flag;
	}
	printf("%lf", sum);
	return 0;
}

11.在一个有序数组中查找具体的某个数字
#include <stdio.h>

int main()
{
	int arr[] = {1,2,3,4,5,6,7,8,9,10};
	int k = 7;
	int size = sizeof(arr) / sizeof(arr[0]);  // 得到数组的元素个数
	int left = 0;
	int right = size - 1;
	while (left <= right)
	{
		int mid = (left + right) / 2;
		if (arr[mid] < k)
		{
			left = mid + 1;
		}
		else if (arr[mid] > k)
		{
			right = mid - 1;
		}
		else
		{
			printf("%d", arr[mid]);
			break;
		}
	}
	if (left > right)
	{
		printf("无效值\n");
	}
	return 0;
}

12.使多个字符从两端向中间汇聚
#include <stdio.h>
#include <string.h>
#include <windows.h>

int main()
{
	char arr1[] = "Like a moth to a flame";
	char arr2[] = "xxxxxxxxxxxxxxxxxxxxxx";
	int left = 0;
	int right = strlen(arr1) - 1;
	while (left <= right)
	{
		arr2[left] = arr1[left];
		arr2[right] = arr1[right];
		printf("%s\n", arr2);
		Sleep(1000);  //休息，单位毫秒，需要引用windows.h头文件
		//如果要求一行实现，可以添加一个清屏
		//如果要添加清屏，要在循环外加一个打印，否则最终结果是空白
		//system("cls");  //清屏
		left++;
		right--;
	}
	//printf("Like a moth to a flame");
	return 0;
}

13.模拟用户登录，仅能尝试三次
#include <stdio.h>
#include <string.h>
#include <windows.h>

int main()
{
	int i = 0;
	char password[20] = { 0 };
	for (i = 0; i < 3; i++)
	{
		printf("正在进行身份验证...\n");
		printf("请输入密码：");
		scanf("%s", password);  ////这里的password不需要使用&是因为它是数组
		if (strcmp(password, "yinghuolight") == 0)
		//比较两个字符串需要用strcmp，不能直接使用==
		//使用strcmp需要引用头文件string.h
		{
			printf("身份验证成功\n");
			break;
		}
		else
		{
			printf("身份验证失败，请重新验证\n");
			Sleep(1000);
			system("cls");
		}
	}
	if (i == 3)
	{
		printf("身份验证失败，退出程序");
	}
	return 0;
}

14.制作一个猜数字游戏
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void menu()  //创建meun函数
{
	printf("xxxxxxxxxxxxxxxxxxxxxxxxxx\n");
	printf("----------1.play----------\n");
	printf("----------2.eixt----------\n");
	printf("xxxxxxxxxxxxxxxxxxxxxxxxxx\n");
}

void game()
{
	int ret = rand() % 100 + 1;
	//%100的余数是0-99，加1之后范围就是1-100了
	//rand函数可以用于生成随机数，需要引用stdlib.h头文件
	//使用rand的同时要搭配srand函数使用，要先设置srand函数
	//rand生成范围是0-32767
	int guess = 0;
	while (1)
	{
		printf("猜猜数字:>");
		scanf("%d", &guess);
		if (guess < ret)
		{
			printf("猜小了\n");
		}
		else if (guess > ret)
		{
			printf("猜大了\n");
		}
		else
		{
			printf("猜对了\n");
			break;
		}
	}
}

int main()
{
	int input = 0;
	srand((unsigned int)time(NULL));
	//srand，随机数的生成器，要求unsigned int类型，需要引用stdlib.h头文件
	//srand要求一个动态量，计算机的时间就是一个动态量，也就是利用时间戳
	//利用时间戳需要引用time函数，time函数需要引用time.h头文件
	//time使用的数据类型是特殊的整型，需要强制转换成unsigned int类型
	//time本身具有参数，填入NULL不使用time的参数
	//rand和srand两者均与随机数相关，按道理应该放在一起，而实际不是
	//原因在于srand是随机数的生成器，仅需要引用一次便可
	//放在循环中会反复生成，这导致短时间内可能出现随机数的重复
	//game函数在循环之中，要想srand即先于rand，又要仅运行一次
	//放在main函数之下便可
	do
	{
		menu();  //引用menu函数
		scanf("%d", &input);
		switch (input)
		{
		case 1:
			game();
			printf("猜数字\n");
			break;
		case 2:
			printf("退出游戏\n");
			return 0;
		default:
			break;
		}

	} while (input);
	return 0;
}

添加修饰的猜数字游戏
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>

void menu()
{
	printf("xxxxxxxxxxxxxxxxxxxxxxxxxx\n");
	printf("----------1.play----------\n");
	printf("----------2.eixt----------\n");
	printf("xxxxxxxxxxxxxxxxxxxxxxxxxx\n");
}

void game()
{
	int ret = rand() % 100 + 1;
	int guess = 0;
	int hp = 100;
	while (1)
	{
		printf("HP=%d\n", hp);
		printf("猜猜数字:>");
		scanf("%d", &guess);
		if (guess < ret)
		{
			printf("猜小了\n");
			hp = hp - 10;
			printf("你遭受荧火light的攻击，HP-10\n");
			printf("HP=%d\n", hp);
			Sleep(1000);
			system("cls");
			if (hp == 0)
			{
				printf("很遗憾，你最终惨死在荧火light手下\n");
				break;
			}
		}
		else if (guess > ret)
		{
			printf("猜大了\n");
			hp = hp - 10;
			printf("你遭受荧火light的攻击，HP-10\n");
			printf("HP=%d\n", hp);
			Sleep(1000);
			system("cls");
			if (hp == 0)
			{
				printf("很遗憾，你最终惨死在荧火light手下\n");
				break;
			}
			
		}
		else
		{
			printf("猜对了\n");
			printf("在你的不懈努力之下，你最终击败了荧火light\n");
			break;
		}
	}
}

int main()
{
	int input = 0;
	srand((unsigned int)time(NULL));
	menu();
	scanf("%d", &input);
	Sleep(1000);
	system("cls");
	switch (input)
	{
	case 1:
		game();
		break;
	case 2:
		printf("退出游戏\n");
		break;
	default:
		break;
	}
	return 0;
}

//////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
void 无返回值函数
平时使用的函数需要return结束使用或者返回值
当声明函数不需要返回值时，使用void

//////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
函数（重点）

函数的简单认识应用和运用符
1.定义一个函数
Add(int x, int y)  //Add可以随意更换，xyz同理
{
    int z = 0;
    z = x + y;
    return z;
}
这就是简单的函数定义，写在主体（main）外

2.应用函数
数据类型 变量名 = 函数名(变量名1,变量名2)

例：
#include <stdio.h>

Add(int x, int y)
{
    int z = 0;
    z = x + y;
    return z;
}

int main()
{
    int a = 0;
    int b = 0;
    int sum = 0;
    scanf("%d %d",&a,&b);
    sum = Add(a, b);
    printf("%d", sum);
    return 0;
}

C语言运算细则
1.小数的获取（数字运算）
double b = 9 / 2;      // b 的值是 4.000000
double c = 9 / 2.0;    // c 的值是 4.500000
double d = 9.0 / 2.0;  // d 的值是 4.500000
但是值得注意的是，这仅限于数字之间的运算，像上述代码那样运算方都是数字
而不是这些
double a = 20;
a = a / 15;   结果为0.666667
a = a / b;

操作符(运算符)
算术操作符
+  -  *  /  %
加 减 乘 除 取余

位操作符
<<         >>
左移操作符 右移操作符

&      |      ^       
按位与 按位或 按位异或

赋值操作符
=  +=  -=  *=  /=  %=  <<=  >>=  &=  ^=  |=
+= ^=这类属于复合赋值，具体意思对应上文再结合赋值便可知道
例如 int a = 2  a = a + 5 -> a += 5

单目操作符
!           &       *         sizeof()
逻辑反操作  取地址  解引用  计算变量大小

~                       ()
取反                    强制类型转换
对二进制位每一位取反    int a = (int)3.14

逻辑运算符
&&  ||    !
并  或者  逻辑相反

关系运算符
==   !=     >    <    >=     <=
等于 不等于 大于 小于 大于等 小于等

条件操作符 (C++)
exp1 ? exp2 : exp3
exp1成立，exp2计算，结果为exp2
exp1不成立，exp3计算，结果为exp3

逗号表达式 (C++)
exp1,exp2,exp3,.......expx
从左往右计算，结果为末位
int a = 0;
int b = 3;
int c = 5;
int d = (a = b + 2, c = a - 4, b = c + 2);

函数的进阶学习
函数是什么？
在维基百科中，函数被定义为子程序
在计算机科学中，子程序被定义为一个大型程序中的部分代码
相较于其他的代码，这部分代码具有相对的独立性
由一个或多个语句块组成，它负责完成某一项特定的工作
函数一般有输入参数和返回值，提供了对过程的封装和细节的隐藏
这些代码通常被集成为软件库

C语言中函数分为库函数和自定义函数
在学习和使用编程中，有些时候我们会频繁使用一些功能
为了提高程序的效率和支持可移植性
C语言提供了一系列库函数来方便开发

如何学习库函数?
https://cplusplus.com/reference/
MSDN(microsoft developer network)
https://zh.cppreference.com/
上述的网站/工具可以方便我们查阅头文件中包含的库函数

常用库函数
IO函数（输入输出函数）
如：printf,scanf,getchar,putchar
字符串操作函数
如：strcmp,strlen,strcpy
字符操作函数
如：toupper
内存操作函数
如：memcpy,memcmp,memset
时间/日期函数
如：time
数学函数
如：sqrt,pow
其他库函数

使用cplusplus学会库函数的使用
https://cplusplus.com/

strcpy 拷贝字符串，需要引用string.h
char * strcpy ( char * destination, const char * source );
char * destination 字符串的目标点，类型为字符数据类型（char）
char * source 字符串的来源，类型为字符数据类型（char）
#include <stdio.h>
#include <string.h>

int main()
{
    char arr[20] = { 0 };
    char arr2[] = "fly fire";
    strcpy(arr, arr2);
    return 0;
}
上述的结果是arr2的字符串拷贝到到arr

自定义函数
函数的基本组成形式
ret_type fun_name(paral, *)
{
	statement;  //语句项
}
ret_type 返回类型
fun_name 函数名字
paral    函数参数

写一个能够找出两个整数中的最大值的函数
#include <stdio.h>

find_max(int x, int y)
{
	int z = 0;
	if (x > y)
	{
		z = x;
	}
	else
	{
		z = y;
	}
	return z;
}

int main()
{
	int a = 0;
	int b = 0;
	scanf("%d %d", &a, &b);
	int max = find_max(a, b);
	printf("max=%d\n", max);
	return 0;
}

写一个能够交换两个整形的函数
#include <stdio.h>

void exchange(int x, int y)
{
	int z = 0;
	z = x;
	x = y;
	y = z;
}

int main()
{
	int a = 0;
	int b = 0;
	scanf("%d %d", &a, &b);
	exchange(a, b);
	printf("%d %d", a, b);
	return 0;
}
上述的代码从理论上来说，的确是交换整形
然而实际上结果却是不交换
为什么呢，打开调试，对a,b,x,y,z进行监视
你会发现a=x,b=y，并没有什么问题
但是你要是监视&a,&b,&x,&y，也就是监视它们的地址
你会发现&a!=&x,&b!=&y，明显，x,y使用的地址不同于a,b
这意味着它们之间的影响毫不相干，因而，我们需要从地址入手

利用指针解决上述
#include <stdio.h>

void exchange(int* pa, int* pb)
{
	int z = 0;
	z = *pa;
	*pa = *pb;
	*pb = z;
}

int main()
{
	int a = 0;
	int b = 0;
	scanf("%d %d", &a, &b);
	exchange(&a, &b);
	printf("%d %d", a, b);
	return 0;
}

函数的参数分为实际参数和形式参数
void exchange(int* pa, int* pb)  //*pa,*pb为形式参数
{
	int z = 0;
	z = *pa;
	*pa = *pb;
	*pb = z;
}
这一块叫做函数定义

exchange(&a, &b);  //叫做函数调用
&a,&b叫做实际参数
简单来说就是要传递过去的叫实际函数，定义的叫形式参数
实际参数可以是常量，表达式，变量，函数，无论是哪一种
在调用时，都必须有确切的值
形式参数是在调用后生成的，在出函数后自动销毁

函数的调用
函数分为两种调用，分别是传址调用和传值调用

传值调用
函数的形参和实参分别占用不同的内存块，对形参进行修改不会影响实参

传址调用
传址调用是把函数外部创建变量的内存地址传递给函数参数
函数内部可以对外部进行修改

函数调用的练习
1.写一个函数判断一个数是不是素数
#include <stdio.h>
#include <math.h>

int is_prime(int n)
{
	int j = 0;
	for (j = 2; j <= sqrt(n); j++)
	{
		if (n % j == 0)
		{
			return 0;
		}
	}
	return 1;
}

int main()
{
	int i = 0;
	scanf("%d", &i);
	if (i <= 1)
	{
		printf("不是素数");
		return 0;
	}
	if (is_prime(i) == 1)
	{
		printf("是素数");
	}
	else
	{
		printf("不是素数");
	}
	return 0;
}
我跟的那个教学并不是判断一个任意数
而且他那个就是循环100-200判断的方法，重复了
这里用的代码是我自己的
另外，函数仅是负责完成自己的工作，不需要承担其他工作
像上述代码中的函数，你可以尝试在函数中加入打印
你会发现它的效果非常差，这不是一种很好的风格

2.写一个函数判断一年是不是闰年
#include <stdio.h>

int is_prime(int n)
{
	if (((n % 4 == 0) && (n % 100 != 0)) || (n % 400 == 0))
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

int main()
{
	int i = 0;
	scanf("%d", &i);
	if (is_prime(i) == 1)
	{
		printf("是闰年");
	}
	else
	{
		printf("不是闰年");
	}
	return 0;
}

3.写一个函数实现一个整形有序数列的二分查找
#include <stdio.h>

int search(int arr[], int k, int size)
{
	int left = 0;
	int right = size - 1;

	while (left <= right)
	{
		int mid = (left + right) / 2;
		if (arr[mid] > k)
		{
			right = mid - 1;
		}
		else if (arr[mid] < k)
		{
			left = mid + 1;
		}
		else
		{
			return mid;
		}
	}
	return -1;
}

int main()
{
	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
	int k = 7;
	int size = sizeof(arr) / sizeof(arr[0]);
	int ret = search(arr, k, size);

	if (ret == -1)
	{
		printf("找不到");
	}
	else
	{
		printf("%d", arr[ret]);
	}
	return 0;
}

4.写一个函数，每调用一次函数，num的值增加1
#include <stdio.h>

void increase(int* x)
{
	(*x)++;
}

int main()
{
	int num = 0;
	increase(&num);
	printf("%d\n", num);
	return 0;
}

函数的嵌套调用
函数可以嵌套调用，但不能嵌套定义
void test3()
{
	printf("yhlight\n");
}

int test2()
{
	test3();
	return 0;
}

int main()
{
	test2();
	return 0;
}

函数的链式访问
把一个函数的返回值作为另一个函数的参数
#include <stdio.h>
#include <string.h>

int main()
{
	int len = strlen("abc");
	printf("%d\n", len);
	return 0;
}
上述代码中先求len的长度，再打印
实际上还有一种写法，strlen返回一个整形给len
len又作为printf的参数，那么可以写成
printf("%d\n", strlen("abc"));这种形式
将一个函数的返回值作为另一个函数的参数，这就是链式访问

strpcy链式访问
#include <stdio.h>
#include <string.h>

int main()
{
	char arr1[20] = { 0 };
	char arr2[] = "yinghuolight";
	strcpy(arr1, arr2);
	printf("%s", strcpy(arr1, arr2));
	return 0;
}

某些有趣的链式访问
#include <stdio.h>

int main()
{
	printf("%d", printf("%d", printf("%d", 43)));
	return 0;
}
上述打印的结果是4321
printf返回的是打印在屏幕上的字符的个数
在打印完43后，返回了一个2给下一个printf，
于是下一个printf打印了一个2，由此类推
最终打印结果是4321

函数的定义
函数的定义是指函数的具体实现，交代如何实现功能

函数的声明
编译器是从前往后编译，若想要将函数写在函数引用之后
需要进行声明，函数要满足先声明再使用
定义在函数引用之前不需要进行引用
#include <stdio.h>

int main()
{
	int a = 10;
	int b = 20;
	int add(int, int);  //告知存在这个函数
	//写成(int x, int y)也行
	int c = add(a, b);
	printf("%d", c);
	return 0;
}

add(int x, int y)
{
	int z = 0;
	z = x + y;
	return z;
}
实际上，函数写在前或者后面这种情况是比较少用的
函数的声明一般是在头文件里进行的，在要使用时引用头文件便可以了

如何创建头文件
打开你的解决方案资源管理器，选择头文件
创建xxx.h文件

如何使用头文件
#include "xxx.h"，不是<>
<>是引用系统或标准库的头文件，也就是内部的库文件
而""是引用外部的库文件

项目类加密
解决方案资源管理器中，右键项目，属性更改配置类型为静态库
通过这样的形式可以让c和h文件编译成一个静态库，代码均编译成二进制格式
仅有进行反编译才能够得到代码

如何使用静态库
#pragma comment(lib,"xxx.lib")

模块化工作（重要！）
假设一个项目需要多个程序员共同进行，这个时候需要各个程序员的分工合作
为了更好的工作，不互相打扰，我们需要拆分模块
假设一个项目由荧火light和睡扬负责，分别需要实现激光轨迹和光棱轨迹
这个时候仅需要荧火light创建laser.c和laser.h文件进行功能的书写
睡扬创建mirror.c，mirror.h进行功能的实现
到时候再由其中任意一位进行集成代码
laser.c和laser.h可以不同名字，仅是方便区分

函数的递归（重要）
程序调用自身的编程技巧称为递归，递归作为算法在程序设计语言中广泛应用
一个过程或者函数在其定义或说明中有直接或间接调用自身的一种方法
递归通常用于把一个复杂问题转化为一个较小的问题来求解
递归策略仅需要少量的程序就能够描绘出解题过程中所需要的多次重复计算
大大减少了程序的代码量，递归的思考方式是把大事化小
#include <stdio.h>

int main()
{
	main;
	return 0;
}
上述代码就是一个简单的递归，你可以通过上述来简单了解何为调用自身

递归的两个必要条件
1.存在限制条件，当满足这个限制条件的时候，递归便不再继续
2.每次递归调用之后越来越接近限制条件

递归的限制
1.不能递归过于深入，造成栈溢出

上述两个条件缺一不可，缺少一定错，但是同时存在不一定对
如：
#include <stdio.h>

void test(int i)
{
	if (i < 10000)
	{
		test(i + 1);
	}
}

int main()
{
	test(1);
	return 0;
}
上述代码两个条件都满足，但是这个代码不对
这里面会出现一个报错，叫做栈溢出
在内存中，有栈区，堆区，静态区，代码区
栈区中存放局部变量，函数的形参
堆区是用来动态内存分配的
静态区用来存放全局变量，静态变量
每一次函数的调用都需要在栈区中生成一个新的空间用来存放
这个所用区间被称为栈帧空间，栈帧空间中再生成空间用来存放
若递归次数过多，栈区迟早会被耗干，就会出现栈溢出现象

递归的迭代
1.求n的阶乘（不考虑溢出）
#include <stdio.h>

int fac(int n)
{
    if (n <= 1)
    {
        return 1;
    }
    else
    {
        return n * fac(n - 1);
    }
}

int main()
{
    int n = 0;
    scanf("%d", &n);
    int ret = fac(n);
    printf("%d", ret);
    return 0;
}

2.求第n个斐波那契数（不考虑溢出）
#include <stdio.h>

int fac(int x)
{
    if (x == 0)
    {
        return 1;
    }
    else if (x == 1)
    {
        return 1;
    }
    else
    {
        return  fac(x - 1) + fac(x - 2);
    }
}

int main()
{
    int n = 0;
    scanf("%d", &n);
    int acc = fac(n);
    printf("%d", acc);
    return 0;
}

循环版本
使用递归效率过低，改用循环
此版本仅供学习，这个代码所计算的结果是不对的
当n>46时，输出结果均为错误结果，此时已经超出了int的范围
#include <stdio.h>

int fac(int x)
{
    int a = 1;
    int b = 1;
    int c = 1;
    while (x > 2)
    {
        c = a + b;
        a = b;
        b = c;
        x--;
    }
    return c;
}

int main()
{
    int n = 0;
    scanf("%d", &n);
    int acc = fac(n);
    printf("%d", acc);
    return 0;
}

迭代经典题目（自主研究）
1.汉诺塔
2.青蛙跳台阶

递归的练习
1.接受一个整形值（无符号），按顺序打印它的每一位
#include <stdio.h>

void print(unsigned int n)
{
	if (n > 9)
	{
		print(n / 10);
	}
	printf("%d ", n % 10);
}

int main()
{
	unsigned int i = 0;
	scanf("%u", &i);
	print(i);
	return 0;
}

2.编写函数不允许创建临时变量，求字符串的长度
#include <stdio.h>

int my_strlen(char* str)
{
	if (*str != '\0')
	{
		return 1 + my_strlen(str+1);  //注意不能使用str++和++str
	}
	else
	{
		return 0;
	}
}

int main()
{
	char arr[] = "yhlight";
	printf("%d", my_strlen(arr));
	return 0;
}

函数的综合练习
1.求n的阶乘
#include <stdio.h>

int fac(int x)
{
    int a = 0;
    int rets = 1;
    for (a = 1; a <= x; a++)
    {
        rets = rets * a;
    }
    return rets;
}

int main()
{
    int n = 0;
    scanf("%d", &n);
    int ret = fac(n);
    printf("%d", ret);
    return 0;
}

2.打印乘法口诀表
#include <stdio.h>

void print_tab(int x)
{
	int i = 0;
	for (i = 1; i <= x; i++)
	{
		int j = 0;
		for (j = 1; j <= i; j++)
		{
			printf("%d*%d=%d ", i, j, i * j);
		}
		printf("\n");
	}
}

int main()
{
	int n = 0;
	scanf("%d", &n);
	print_tab(n);
	return 0;
}

3.使一段字符反序
#include <stdio.h>

my_strlen(char* str)
{
	int count = 0;
	while (*str != '\0')
	{
		count++;
		str++;
	}
	return count;
}

void reverse_string(char* str)
{
	int left = 0;
	int right = my_strlen(str)-1;
	while (left < right)
	{
		char tmp = str[left];
		str[left] = str[right];
		str[right] = tmp;
		left++;
		right--;
	}
}

int main()
{
	char arr[] = "abcdefg";
	reverse_string(arr);
	printf("%s\n", arr);
	return 0;
}

指针写法
#include <stdio.h>

my_strlen(char* str)
{
	int count = 0;
	while (*str != '\0')
	{
		count++;
		str++;
	}
	return count;
}

void reverse_string(char* str)
{
	int left = 0;
	int right = my_strlen(str)-1;
	while (left < right)
	{
		char tmp = *(str + left);
		*(str + left) = *(str + right);
		*(str + right) = tmp;
		left++;
		right--;
	}
}

int main()
{
	char arr[] = "abcdefg";
	reverse_string(arr);
	printf("%s\n", arr);
	return 0;
}

递归式写法
#include <stdio.h>

my_strlen(char* str)
{
	int count = 0;
	while (*str != '\0')
	{
		count++;
		str++;
	}
	return count;
}

void reverse_string(char* str)
{
	char tmp = *str;
	int len = my_strlen(str);
	*str = *(str + len - 1);
	*(str + len - 1) = '\0';
	if (my_strlen(str+1)>=2)
	{
		reverse_string(str + 1);
	}
	*(str + len - 1) = tmp;
}

int main()
{
	char arr[] = "abcdefg";
	reverse_string(arr);
	printf("%s\n", arr);
	return 0;
}

4.输入任意非负整数，返回组成它的数字之和
#include <stdio.h>

typedef unsigned int unint;

int DigitSum(unint i)
{
	if (i > 9)
	{
		return DigitSum(i / 10) + i % 10;
	}
	else
	{
		return i;
	}
}

int main()
{
	unint i = 0;
	scanf("%d", &i);
	int sum = DigitSum(i);
	printf("%d", sum);
	return 0;
}

5.使用递归求n的k次方
#include <stdio.h>

double Pow(int n, int k)
{
	if (k == 0)
	{
		return 1.0;
	}
	else if (k > 0)
	{
		return n * Pow(n, k - 1);
	}
	else
	{
		return 1.0 / (Pow(n, -k));
	}
}

int main()
{
	int n = 0;
	int k = 0;
	scanf("%d %d", &n, &k);
	double ret = Pow(n, k);
	printf("%lf", ret);
	return 0;
}

//////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
操作符
1.操作符的分类
操作符分为
{
   算数操作符
   移位操作符
   位操作符
   赋值操作符
   单目操作符
   关系操作符
   逻辑操作符
   条件操作符
   逗号操作符
   下标引用,函数调用和结构成员
}

算数操作符
+   -   *   /   %
加  减  乘  除  取模
使用取模操作符两端必须是两个整数

算数操作符浮点数求法
#include <stdio.h>

int main()
{
	double a = 3.0 / 5; //double a = 3.0 / 5.0
	printf("%lf", a);
	return 0;
}

移位操作符
<<         >>
左移操作符 右移操作符
作用是把某个数的二进制位移动一位

右移操作符有两种移动方式
1.算术右移
右边丢弃，左边补原符号位
2.逻辑右移
右边丢弃，左边补零

位操作符
&      |      ^       
按位与 按位或 按位异或
这三个操作符只能用于整型

按位与的作用是对两者的二进制位进行比较，若此位两者皆为0，则此位为0
若此位两者分别为1,0，则此位为0，若此位两者皆为1，则此位为1，重新组成一个二进制位
例如：
int a = 3 & 5;
3   0000000000000011
5   0000000000000101
a   0000000000000001
a的结果为1

按位或的作用是对两者的二进制位进行比较，若此位两者之中至少有一位为1，则此位为1
若两者皆为0，则此位为0，重新组成一个二进制位

按位异或的作用对两者的二进制位进行比较，若此位两者相同，则此位为0，若此位两者不同
则此位为1，重新组成一个二进制位
例如：
不创建变量，交换两个数字
#include <stdio.h>

int main()
{
	int a = 12;
	int b = 15;
	printf("%d %d\n", a, b);
	a = a ^ b;
	b = a ^ b;
	a = a ^ b;
	printf("%d %d\n", a, b);
	return 0;
}

位操作符综合练习
1.求一个整数存储在内存中的二进制中1的个数
#include <stdio.h>

int main()
{
	int num = 10;
	int count = 0;
	while (num != 0)
	{
		if ((num & 1) == 1)
		{
			count++;
		}
		num >>= 1;
	}
	printf("%d", count);
	return 0;
}
10的二进制位00001010
1的二进制位 00000001

2.修改二进制位中的某一位
#include <stdio.h>

int main()
{
	int num = 13;
	int i = num | (1 << 4);
	printf("%d", i);
	return 0;
}
i = 29
使用按位或和左移操作符
13   0000000000001101
     0000000000100000
     0000000000101101

赋值操作符
=  +=  -=  *=  /=  %=  <<=  >>=  &=  ^=  |=

连续赋值（不建议使用）
在C语言中，允许连续赋值
#include <stdio.h>

int main()
{
	int num = 13;
	int i = 1;
	int x = 0;
	x = num = num - i;
	printf("%d", x);
	return 0;
}

单目操作符
!           &       sizeof()      *             +     -
逻辑反操作  取地址  计算变量大小  解引用操作符  正值  负值

~                       ()
取反                    强制类型转换
对二进制位每一位取反    int a = (int)3.14

前置++  后置++  前置--  后置--
++a和a++有着很大区别
前后是赋值的先后，++a是先赋值，后使用
a++先使用，后赋值
例：
int a = 10;
int b = ++a;  //来到这一步后，后续a=11

例如2：
int a = 10;
int b = a++;
这里打印出来的结果是b是10

int a = 10;
int b = ++a;
这里打印出来的结果是b是11

++ --扩展
++ --不仅仅可以用于数值的增加减少，还可以用到指针那边
所以不要顽固地觉得++ --只用于数值的变化

sizeof作为操作符的一些细则
printf("%d", sizeof(x))
printf("%d", sizeof x)
sizeof在计算变量时允许变量不需要括号
但是不允许计算类型时不需要括号
计算类型只能是
printf("%d", sizeof(int))
另外，如果sizeof是函数，那么无论是变量还是类型，必须有括号
函数后面必须有括号

sizeof计算大小的一些细则
#include <stdio.h>

int main()
{
	short s = 5;
	int a = 10;
	printf("%d\n", sizeof(s = a + 2));
	printf("%d\n", s);
	return 0;
}
上述代码中sizeof内部的表达式是不参与运算的
也就是说，sizeof计算的只是s
如果参与运算，sizeof计算的结果应该是4
结果为4是因为编译器默认为int类型

sizeof计算数组的细则
#include <stdio.h>

int main()
{
	int a = 10;
	int arr[10] = { 0 };
	printf("%d", sizeof(arr));
	printf("%d", sizeof(int[10]));
	return 0;
}
int[10]可以表示数组arr的类型
sizeof(int[10])能够计算整个数组的大小
但是sizeof(int[])这种是不允许的

关系操作符
>  >=  <  <=  !=  ==

不允许使用==比较相等的情况
1.比较两个字符串需要用strcmp，不能直接使用==

逻辑操作符
&&      ||      !
逻辑与  逻辑或  逻辑相反

在计算机中，0为假，1为真

逻辑操作符综合练习
1.了解逻辑与和逻辑或的特点
#include <stdio.h>

int main()
{
	int i = 0, a = 0, b = 2, c = 3, d = 4;
	i = a++ && ++b && d++;
	//i = a++ || ++b || d++;
	printf("a=%d\nb=%d\nc=%d\nd=%d", a, b, c, d);
	return 0;
}
逻辑与的情况下，a++先使用后赋值，a=0，即a为假，也就说
a++后面都没有进行，所以答案才会是1，2，3，4

逻辑或的情况下，a++先使用后赋值，a=0，即a为假，这个时候，
程序会继续向后，直到找到真或走出i，所以程序只是走到++b就往下了
答案才会是1，3，3，4

条件操作符（三目操作符）
exp1 ? exp2 : exp3
exp1成立，exp2计算，结果为exp2
exp1不成立，exp3计算，结果为exp3

逗号表达式
exp1,exp2,exp3,.......expx
从左往右计算，结果为末位
#include <stdio.h>

int main()
{
	int a = 0;
	int b = 3;
	int c = 5;
	int d = (a = b + 2, c = a - 4, b = c + 2);
	printf("%d", d);
	return 0;
}

逗号表达式场景说明
1.集成计算的if
#include <stdio.h>

int main()
{
	int a = 1, b = 2, c = 3, d = 4;
	if (a = b + 1, c = a / 2, d > 0)
	{
		printf("%d\n", d);
	}
	else
	{
		printf("%d %d %d %d", a, b, c, d);
	}
	return 0;
}

2.先执行式while循环
a = get_val;
count_val(a);
while (a > 0)
{
    a = get_val;
    count_val(a);
}
可以改写成
while (a = get_val, count_val(a), a > 0)
{

}

下标引用,函数调用和结构成员

下标引用操作符[]
#include <stdio.h>

int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	printf("%d", arr[4]);
	return 0;
}
操作数
对于上述代码的[]，arr和4是它的操作数

函数调用操作符()
#include <stdio.h>

int ADD(int x, int y)
{
	return x + y;
}

int main()
{
	int a = 10;
	int b = 20;
	int sum = ADD(a, b);
	printf("%d", sum);
	return 0;
}
ADD(a, b)中的()就是函数调用操作符
函数不得省略括号或者没有括号
对于()来说，它的操作数为ADD，a，b

结构成员操作符->
#include <stdio.h>

struct yhlight
{
	char name[20];
	int age;
	char skill[100];
};

int main()
{
	struct yhlight YH = { "yinghuolight",21,"擅长使用幻体及火焰" };
	struct yhlight* pYH = &YH;
	printf("%s %d %s\n", pYH->name, pYH->age, pYH->skill);
	return 0;
}
可以去看看结构体struct那节

表达式求值中的类型转换
隐式类型转换（整型提升）
C的整型算术运算总是至少以缺省整形类型的精度来进行的
为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型
以下为例
char a, b, c;
...
a = b + c;
b和c的值会被提升成普通整型，然后再执行加法运算
由于a仍是char类型，空间为1个字节
而b和c被提升为普通整型，为4个字节
把普通整形存到char类型中，会发生截断
截断分多个场景和情况，这里不进行说明
在这里可以认为这种说法是正确的
截断就是将最低需求的字节保存下来，其他字节抛弃

整型提升的实例
#include <stdio.h>

int main()
{
    char a = 3;
    char b = 127;
    char c = a + b;
    printf("%d", c);
    return 0;
}
这里a，b都是char类型，都没有达到一个int的大小，会发生整型提升
3的二进制     00000000000000000000000000000011
a的二进制     00000011
127的二进制   00000000000000000000000001111111
b的二进制     01111111
整型提升是按照符号位来提升的
如果a=-3，那么它的整型提升是11111111111111111111111111111101
a   00000000000000000000000000000011
+                                      =00000000000000000000000010000010
b   00000000000000000000000001111111

c   10000010
但是我要打印一个整型，所以发生了整型提升
c   11111111111111111111111110000010（补码）
但是打印出来的是数字，用的是原码
那么c应该是10000000000000000000000001111110
所以最终呈现的结果是-126

算术转换
如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为
另一个操作数的类型，否则操作就无法进行

下面是一个层次体系，称为寻常算术转换
long double
double
float
unsigned long int
long int
unsigned int
int

操作符的属性
1.优先级
2.结合性
3.是否控制求值顺序

优先级决定计算顺序，当优先级不起作用时，结合性决定计算顺序
是否控制求值顺序则是逻辑与，逻辑或，还有条件操作符，逗号表达式
它们有着特别的计算顺序

一些问题表达式（代码规范）
#include <stdio.h>

int main()
{
    int a = 4;
    int b = 5;
    int c = 6;
    int d = 7;
    int e = 8;
    int f = 9;
    int ret = a * b + c * d + e * f;
    printf("%d", ret);
    return 0;
}
上述代码有两种顺序，分别是
a * b  +  c * d  +  e * f
  1    4    2    5    3
a * b  +  c * d  +  e * f
  1    3    2    5    4
这里说明，即便你了解，掌握了操作符
你也没有办法确认唯一的顺序
所以我们进行拆分，不要这样子写

c + --c
这种同样有问题的，--C的优先级的确先于C
但是你左侧的C你无法确定
假设c=3，那么会有两种情况
3+2=5 / 2+2=4
今后不要写出这样的玩意

#include <stdio.h>

int fun()
{
	static int count = 1;
	return ++count;
}

int main()
{
	int answer;
	answer = fun() - fun() * fun();
	printf("%d", answer);
	return 0;
}
这一种也有问题，虽然大多数编译器计算出来的结果是一样的
但是你不清楚函数调用的顺序，不知道哪个函数先调用

内容扩展：反汇编
#include <stdio.h>

int main()
{
	int i = 1;
	int ret = (++i) + (++i) + (++i);
	printf("%d", ret);
	return 0;
}
F10打开调试，使代码走到int i = 1;这里
右键，转到反汇编
00007FF6A7B227B3  mov         eax,dword ptr [i]
将变量 i 的值加载到寄存器 eax 中

00007FF6A7B227B6  inc         eax  
将 eax 的值加 1

00007FF6A7B227B8  mov         dword ptr [i],eax 
将 eax 的值存回变量 i

00007FF6A7B227BB  mov         eax,dword ptr [i] 
再次将 i 的值加载到 eax 中

00007FF6A7B227BE  inc         eax  
再次将 eax 的值加 1

00007FF6A7B227C0  mov         dword ptr [i],eax 
将新的 eax 值存回变量 i

00007FF6A7B227C3  mov         eax,dword ptr [i]  
继续将 i 的值加载到 eax 中

00007FF6A7B227C6  inc         eax  
将 eax 的值再加 1

00007FF6A7B227C8  mov         dword ptr [i],eax
将 eax 的值存回变量 i

00007FF6A7B227CB  mov         eax,dword ptr [i]
再次将 i 的值加载到 eax 中

00007FF6A7B227CE  mov         ecx,dword ptr [i] 
将 i 的值也存入寄存器 ecx

00007FF6A7B227D1  add         ecx,eax  
将 ecx 和 eax 相加，ecx 现在是2 * i

00007FF6A7B227D3  mov         eax,ecx  
将 ecx 的值移动到 eax 中

00007FF6A7B227D5  add         eax,dword ptr [i] 
将 i 的值加到 eax 中

00007FF6A7B227D8  mov         dword ptr [ret],eax
将最终结果存储到变量 ret 中

可以看得出来，vs的计算顺序是先计算i，之后再借助寄存器来算总数
而其他编译器未必是这样的计算顺序，这导致计算结果不同，例如gcc

总结：如果我们写出的表达式不能通过操作符的属性
      确定唯一的顺序，那么这个表达式存在问题

操作符综合练习
求二进制位中有多少个1
使用按位与
#include <stdio.h>

int NumberOf1(int i)
{
	int count = 0;
	while (i != 0)
	{
		if ((i & 1) == 1)
		{
			count++;
		}
		i >>= 1;
	}
	return count;
}

int main()
{
	int i = 15;
	int ret = NumberOf1(i);
	printf("%d", ret);
	return 0;
}

算式运算（不考虑负数）
#include <stdio.h>

int NumberOf1(int i)  //考虑负数+unsigned
{
	int count = 0;
	while (i != 0)
	{
		if (i % 2 == 1)
		{
			count++;
		}
		i = i / 2;
	}
	return count;
}

int main()
{
	int i = 15;
	int ret = NumberOf1(i);
	printf("%d", ret);
	return 0;
}

还有高手
#include <stdio.h>

int NumberOf1(int i)
{
	int count = 0;
	while (i != 0)
	{
		i = i & (i - 1);
		count++;
	}
	return count;
}

int main()
{
	int i = 15;
	int ret = NumberOf1(i);
	printf("%d", ret);
	return 0;
}

判断一个数是不是2的n次方（不考虑负数）
#include <stdio.h>

void NumberOf1(int i)
{
	if (i != 0 && (i & (i - 1)) == 0)
	{
		printf("是\n");
	}
	else
	{
		printf("不是\n");
	}
}

int main()
{
	int i = 0;
	scanf("%d", &i);
	NumberOf1(i);
	return 0;
}

求两个数二进制位中不同的个数
#include <stdio.h>

int main()
{
	int m = 0;
	int n = 0;
	int i = 0;
	int count = 0;
	scanf("%d %d", &m, &n);
	for (i = 0; i < 32; i++)
	{
		if (((m >> i) & 1) != ((n >> i) & 1))
		{
			count++;
		}
	}
	printf("%d", count);
	return 0;
}

#include <stdio.h>

int NumberOf1(int i)
{
	int count = 0;
	while (i != 0)
	{
		i = i & (i - 1);
		count++;
	}
	return count;
}

int main()
{
	int m = 0;
	int n = 0;
	int i = 0;
	int count = 0;
	scanf("%d %d", &m, &n);
	int ret = m ^ n;
	count = NumberOf1(ret);
	printf("%d", count);
	return 0;
}

打印奇偶位二进制位
#include <stdio.h>

int main()
{
	int i = 0;
	scanf("%d", &i);
	int n = 0;
	for (n = 31; n >= 1; n -= 2)
	{
		printf("%d", (i >> n & 1));
	}
	printf("\n");
	for (n = 30; n >= 0; n -= 2)
	{
		printf("%d", (i >> n & 1));
	}
	return 0;
}

不创建临时变量，交换两个变量
#include <stdio.h>

int main()
{
	int a = 10;
	int b = 20;
	a = a ^ b;
	b = a ^ b;
	a = a ^ b;
	printf("%d %d", a, b);
	return 0;
}

扩展内容:小端存储
#include <stdio.h>

int main()
{
	int arr[] = { 1,2,3,4,5 };
	short* p = (short*)arr;
	int i = 0;
	for (i = 0; i < 4; i++)
	{
		*(p + i) = 0;
	}
	for (i = 0; i < 5; i++)
	{
		printf("%d ", arr[i]);
	}
	return 0;
}

1的二进制表现形式为
0000 0000 0000 0000 0000 0000 0000 0001
16进制表示为 00 00 00 01（4个二进制位表示1个16进制位）
内存的存储有顺序之分
小端存储时，数据存进内存的顺序由低到高
大端存储时，数据存进内存的顺序由高到低
在VS中，数据的存储是小端存储，也就是倒序的形式 01 00 00 00
那么上面的数组arr在内存中的存储时这样的
01 00 00 00 | 02 00 00 00 | 03 00 00 00 | 04 00 00 00 | 05 00 00 00
short* p，short类型的指针空间大小是2个字节
(short*)arr，arr数组进行了强制类型转换，使得它现在是short类型的指针
而原先arr数组存放的是int类型的数据，占用4个字节
那么指针p所指向的的内存区域实际是01 00 | 00 00 | 02 00 | 00 00
由于short类型的指针是两个字节，那么对它们进行解引用操作也是更改两个字节
也就是00 00 | 00 00 | 00 00 | 00 00 |
最后输出的是arr数组，是int类型，也就是
00 00 00 00 | 00 00 00 00 | 03 00 00 00|
这就是为什么输出结果是0 0 3 4 5的原因

//////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
指针
1.指针的初步了解
指针就是内存地址，指针变量是用来存放内存地址的变量

2.指针地址的初步观察
如下代码
#include <stdio.h>

int main()
{
	int a = 10;
	return 0;
}
在VS中 F10启动调试，继续调试，跑完int a这句
然后在调试中找到窗口，再找到内存
在内存窗口中地址一栏中输入&a，定位a的地址
&a拿到的是a的4个字节中第一个字节的地址
你会获得0x000000FA002FF9C4这样的字串
这就是a的地址，值得注意是，每次调试地址均会发生变化

观察0x000000FA002FF9_C4这地址 你会发现他是 0a 00 00 00
这里用的是16进制 一个地址有数个储存单元，单位是字节
int是4个字节，16进制中0a代表10
0a所对应的位置是C4 那么接下来的00是 C5 C6 C7
16进制中 10-15使用a-e代替
每一个字节都有地址，取地址是取首位

打印地址
printf("%p\n", &a); //%p用来打印地址

3.使用地址
int* pa = &a;  //pa用来存放地址

*说明pa是指针变量
int说明pa执行的对象是int类型

#include <stdio.h>

int main()
{
	int a = 10;
	int* pa = &a;  //pa用来存放地址
}

解引用操作
也就是便捷式改变指针指向的内容
#include <stdio.h>

int main()
{
	int a = 10;
	int* pa = &a;
    *pa = 20;  //*pa就是通过pa里边的地址，找到a
}

3.测定指针类型的大小
printf("%d\n",sizeof(char*));
不同机器会有4/8的结果
取决于你的机器是x86（32位）还是x64（64位）

指针（初阶）
在计算机科学中，指针是编程语言中的一个对象
利用地址，它的值直接指向存在电脑存储器中另一个地方的值
由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元
因此，将地址形象化的称为“指针"
意思是通过它能找到以它为地址的内存单元

可以这样理解
内存
一个字节  0xFFFFFFFF
一个字节  0xFFFFFFFE
一个字节
...       ...
一个字节  0x00000002
一个字节  0x00000001
一个字节  0x00000000
内存划分为数个内存单元，内存单元选用一个字节作为基础的内存单元
为了方便管理，给每一个内存单元进行编号，称为地址
通过地址可以很好地找到内存单元，也就说，这个地址指向了内存单元
于是，地址被形象地称为指针

指针的基本知识
#include <stdio.h>

int main()
{
	int a = 10;  //a占4个字节
	int* pa = &a;  //拿到的是a的第一个字节的地址
	//pa用来存放指针，*说明它是指针变量
	*pa = 12;  //解引用操作
	return 0;
}
指针变量的大小看平台，32位是4，64是8

指针和指针类型
#include <stdio.h>

int main()
{
	int* pa;
	char* pc;
	float* pf;
	printf("%d\n", sizeof(pa));
	printf("%d\n", sizeof(pc));
	printf("%d\n", sizeof(pf));
	return 0;
}
sizeof计算不同类型的指针结果是一样的
但是不代表指针类型无意义

探讨指针类型的意义
#include <stdio.h>

int main()
{
	int a = 0x11223344; //16进制，4个二进制位可以表示一个16进制
	int* pa = &a;
	*pa = 0;
	return 0;
}
在这种情况下，a的内存内容会全部更改
#include <stdio.h>

int main()
{
	int a = 0x11223344;
	char* pc = &a;
	*pc = 0;
	return 0;
}
这种情况下，a的内存内容只是改变了第一个字节
它并没有像上面那样将a的内存内容全部更改了
这就说明了1.指针类型决定了指针解引用的权限有多大
#include <stdio.h>

int main()
{
	int arr[10] = { 0 };
	int* p = arr;
	char* pc = arr;
	return 0;
}
这种情况下，尽管*p和*pc的类型不一样，但是两者都能够存放arr
然而它们的步长不同
#include <stdio.h>

int main()
{
	int arr[10] = { 0 };
	int* p = arr;
	char* pc = arr;
	printf("%p\n", p);
	printf("%p\n", p + 1);  //下一个地址需要跳过4个字节
	printf("%p\n", pc);
	printf("%p\n", pc + 1);  //下一个地址只需要跳过1个字节
	return 0;
}
这里说明了2.指针类型决定指针能走多远（步长）

直观步长的不同
#include <stdio.h>

int main()
{
	int arr[10] = { 0 };
	int* p = arr;
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		*(p + i) = 1;  //p+i相当于下标为i的地址，这里的作用是将数组元素全部变为1
	}
	return 0;
}
这是int类型的指针的表现，若是char类型的指针，则无法实现这样的效果
char类型时，p+1只能跳过1个字节，而数组是int类型，意味着需要跳过4个字节
才能到下一个地址，int类型指针则能够跳4个字节，可以以元素为单位来操作
尽管如此，char类型却能够以一个字节来访问，而int不行
这意味着，要根据我们的需求来使用指针的类型

野指针
野指针就是指针指向的位置是不可知的(随机的、不正确的、没有明确限制的

野指针成因
1.指针未初始化
#include <stdio.h>

int main()
{
	int* p;  //没有初始化，局部变量不初始化，默认随机值
	*p = 20;  //非法访问内存
	return 0;
}

2.指针越界访问
#include <stdio.h>

int main()
{
	int arr[10] = { 0 };
	int* p = arr;
	int i = 0;
	for (i = 0; i <= 10; i++)
	{
		*p = i;
		p++;
	}
	return 0;
}

3.指针指向的空间释放（暂且了解）
指针向内存申请了一份空间，在使用后，空间还给了操作系统
但是你这个变量有可能记住了这个地址，再次通过这个指针访问这个地址是非法访问
int* test()
{
	int a = 10;
	return &a;
}

int main()
{
	int* p = test();
	*p = 20;
	return 0;
}

如何避免野指针
1.指针初始化
若不知道指针应该初始化为什么时，直接初始为NULL
2.检查指针是否越界
C语言不检查越界行为
3.指针指向空间释放及时置空
4.指针使用前检查有效性
初始化为空指针不能使用

指针运算
指针+-整数
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int* p = arr;
	int* pend = arr + 9;
	while (p <= pend)
	{
		printf("%d\n", *p);
		p++;
	}
	return 0;
}

指针-指针
#include <stdio.h>

int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	printf("%d", &arr[9] - &arr[0]);
	return 0;
}
指针减去指针，得到的是两个指针之间的元素个数
指针和指针相减的前提是两个指针指向同一个空间

指针-指针实现my_strlen
#include <stdio.h>

int my_strlen(char* str)
{
	char* start = str;
	while (*str != '\0')
	{
		str++;
	}
	return str - start;
}

int main()
{
	char arr[20] = "abc";
	int ret = my_strlen(arr);
	printf("%d", ret);
	return 0;
}

指针的关系运算
#include <stdio.h>

int main()
{
	int* p = 0;
	int num[5] = { 0 };
	for (p = &num[5]; p > &num[0];)
	{
		*--p = 0;
	}
}
[0][1][2][3][4]，假设这是数组的空间
↑    <-     ↑ 从4的末端最终指向0的起端
这就是上述运行的结果，指针指向的变化

另一种写法
#include <stdio.h>

int main()
{
	int* p = 0;
	int num[5] = { 0 };
	for (p = &num[4]; p >= &num[0]; p--)
	{
		*p = 0;
	}
}
这一种在绝大多数编译器是可以完成任务，然而，这种写法是要避免的
从内存空间上来说
[-2][-1][0][1][2][3][4]
  ↑      <-      ↑
可以看到，指针p已经越界访问了，构成了非法访问
数组在内存中的存放是连续的，你可以将一个空间的末端视作另一个空间的起端
这就可以解释为什么会到达[-2]空间了
同时，C语言标准中有规定
允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较
但是不允许与第一个元素之前的那个内存位置的指针进行比较

指针和数组
数组名是数组首元素地址
#include <stdio.h>

int main()
{
	int arr[10] = { 0,1,2,3,4,5,6,7,8,9 };
	printf("%p\n", arr);  //数组名是数组首元素地址
	printf("%p", &arr[0]);
	return 0;
}

验证首元素地址+i等于arr[i]的地址
#include <stdio.h>

int main()
{
	int arr[10] = { 0,1,2,3,4,5,6,7,8,9 };
	int* p = arr;
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		printf("%p <==> %p\n", &arr[i], p + i);
	}
	return 0;
}

二级指针
指针变量也是变量，是变量就会有地址
#include <stdio.h>

int main()
{
	int a = 10;
	int* pa = &a;  //只有一层指向关系，为一级指针
	int** ppa = &pa;  //两层指向关系，为二级指针
	int*** pppa = &ppa;  //三级
	printf("%p\n", pa);
	printf("%p", ppa);
	return 0;
}

指针数组
存放指针的数组
#include <stdio.h>

int main()
{
	int arr[10] = { 0 };  //整型数组
	char ch[5] = { 0 };  //字符数组
	int* parr[5] = { 0 };  //指针数组
	return 0;
}

指针的进阶在下面，另设一篇

//////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
结构体
用来创建一些类型

关键词 struct

#include <stdio.h>

struct stu
{
	char name[20];
	int age;
	double score;
};

int main()
{
	struct stu s = { "yinghuolight",20,85.5 };
	printf("%s %d %lf\n", s.name, s.age, s.score);
	return 0;
}
打印结果是 yinghuolight 20 85.5

使用指针访问
int main()
{
	struct stu s = { "yinghuolight",20,85.5 };
	struct stu* ps = &s;
	printf("%s %d %lf\n", (*ps).name, (*ps).age, (*ps).score);
	return 0;
}

使用指针简化使用
printf("%s %d %lf\n", ps->name, ps->age, ps->score);

结构体（初阶）
结构的基础知识
结构是一些值的集合，这些值被称为成员变量，结构的每一个成员可以是不同类型的变量

结构体的声明
struct tag
{
	member-list;
}variable-list;

#include <stdio.h>

struct yhlight
{
	char name[20];
	int age;
	char introduce[60];
}s1, s2;  //s1，s2也是结构体变量，只不过是全局变量

结构成员的类型
标量，数组，指针，或者其他结构体
struct yhlight_b
{
	int damage;
	int health;
	char skill[20];
};

struct yhlight
{
	struct yhlight_b yh_b;
	char name[20];
	int age;
	char introduce[60];
}s1, s2;

结构体变量的定义和初始化
#include <stdio.h>

struct yhlight
{
	char name[20];
	int age;
	char introduce[60];
}s1, s2;

int main()
{
	struct yhlight yh = { "yinghuolight",21,"荧火光第四席位" };
	struct yhlight s1 = { "yinghuolight",21,"荧火光第四席位" };
	printf("%s %d %s\n", yh.name, yh.age, yh.introduce);
	printf("%s %d %s", s1.name, s1.age, s1.introduce);
	return 0;
}

结构体成员的访问
#include <stdio.h>

struct yhlight_b
{
	int damage;
	int health;
	char skill[20];
};

struct yhlight
{
	char name[20];
	int age;
	struct yhlight_b yh_b;
};

int main()
{
	struct yhlight yh = { "yinghuolight",21,{100,1000,"飞蛾扑火"} };
	printf("%s %d\n", yh.name, yh.age);
	printf("%d %d %s", yh.yh_b.damage, yh.yh_b.health, yh.yh_b.skill);
	return 0;
}

使用指针访问
#int main()
{
	struct yhlight yh = { "yinghuolight",21,{100,1000,"飞蛾扑火"} };
	struct yhlight* pyh = &yh;
	printf("%s %d\n", (*pyh).name, (*pyh).age);
	printf("%d %d %s", (*pyh).yh_b.damage, (*pyh).yh_b.health, (*pyh).yh_b.skill);
	return 0;
}

使用指针简化使用
printf("%s %d\n", pyh->name, pyh->age);
printf("%d %d %s", pyh->yh_b.damage, pyh->yh_b.health, pyh->yh_b.skill);

结构体传参（传值调用）
#include <stdio.h>

struct yhlight
{
	char name[20];
	int age;
};

void print(struct yhlight yh)
{
	printf("%s %d", yh.name, yh.age);
}

int main()
{
	struct yhlight yh = { "yinghuolight",21 };
	print(yh);
	return 0;
}

指针形式（传址调用）
#include <stdio.h>

struct yhlight
{
	char name[20];
	int age;
};

void print(struct yhlight* pyh)
{
	printf("%s %d", pyh->name, pyh->age);
}

int main()
{
	struct yhlight yh = { "yinghuolight",21 };
	print(&yh);
	return 0;
}

//////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
regist 寄存器
大量频繁使用的数据建议存进寄存器
现在的编译器默认会将大量使用数据自动存进

//////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
static 静态的
1.static修饰局部变量
static修饰，改变了变量的存储类型
改变了局部变量的生命周期，和全局变量一样大
#include <stdio.h>

void test()
{
    static int a = 1;   //这里需要你比较有无static的结果
    a++;
    printf("%d ", a);
}

int main()
{
    int i = 0;
    while (i < 10)
    {
        test();
        i++;
    }
    return 0;
}
在无static的时候，test函数生命周期仅仅是大括号
这导致test函数销毁，不会进入主函数，打印结果会是10个2

有static修饰，test函数出了范围不销毁，再次进入主函数

2.修饰全局变量
static int g_val = 2022; //其他文件
在其他文件使用static修饰的全局变量无法使用extern声明使用

3.修饰函数
同全局

//////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
getchar 获取字符
putchar 输出字符
getchar在正确读取时，返回值是字符的ASCII值
getchar，putchar的类型只能是int
不正确读取时，或者文件结束，返回EOF值
EOF-END OF FILE 文件结束标志

#include <stdio.h>

int main()
{
	int ch = getchar();
	putchar(ch);
	return 0;
}
上述代码的意思是，getchar读取键盘的一个字符储存到ch中

循环读取字符
#include <stdio.h>

int main()
{
	int ch = 0;
	while ((ch = getchar()) != EOF)
	{
		putchar(ch);
	}
	return 0;
}
上述代码作用是不断读取键盘字符，不结束
想要结束可以通过ctrl+z

换行的解析
上述代码会自带一个换行，原因在于
getchar与键盘之间存在一个缓冲区，输入字符和回车后
字符\n被存入缓冲区，而getchar仅读取了字符便继续进程了
然后再次返回循环，读取缓冲区中的\n

缓冲区是用来短暂存放输入的内容，直到回车确认后才输入程序

多个输入之间关联
#include <stdio.h>

int main()
{
	char password[20] = { 0 };
	printf("请输入密码：");
	scanf("%s", password);
	printf("请确认密码(Y/N)");
	//清理缓冲区getchar();
	int ch = getchar();
	if (ch == 'Y')
	{
		printf("确认成功\n");
	}
	else
	{
		printf("确认失败\n");
	}
	return 0;
}
上述运行后，输入密码后会直接失败
原因在于scanf拿走了缓冲区中的密码，剩余\n
缓冲区中还有东西，getchar会直接拿走
if就无法成立直接跳else

解决方法：清除\n，添加一个getchar清理缓冲区
在VS2022版本，scanf_s要添加一个整形参数，否则依旧失败

处理多个无用字符
#include <stdio.h>

int main()
{
	char password[20] = { 0 };
	printf("请输入密码：");
	scanf("%s", password);
	printf("请确认密码(Y/N)");
	int tmp = 0;
	while ((tmp = getchar() != '\n'))
	{
		;
	}
	int ch = getchar();
	if (ch == 'Y')
	{
		printf("确认成功\n");
	}
	else
	{
		printf("确认失败\n");
	}
	return 0;
}

strcpy 拷贝字符串，需要引用string.h
char * strcpy ( char * destination, const char * source );
char * destination 字符串的目标点，类型为字符数据类型（char）
char * source 字符串的来源，类型为字符数据类型（char）
#include <stdio.h>
#include <string.h>

int main()
{
    char arr[20] = { 0 };
    char arr2[] = "fly fire";
    strcpy(arr, arr2);
    return 0;
}
上述的结果是arr2的字符串拷贝到到arr

//////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
typedef 类型重定义
typedef unsigned int unint;
写在全局，可以将复杂类型名字简单化

//////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
内存（memory）

类型的基本归类
1.整型家族
char
    unsigned char
	signed char
char类型存储的是ASCII值，也属于整型

short
    unsigned short [int]
	signed short [int]

int
    unsigned int
	signed int

long
    unsigned long [int]
	signed long [int]
[int]表示可省略

2.浮点型家族
float

double

3.构造类型（自定义类型）
数组类型
结构体类型 struct
枚举类型 enum
联合类型 union

4.指针类型

5.空类型
void

原码，反码，补码
数据在内存中的储存方式为补码
而呈现出来的数字则是原码
原码，反码，补码与二进制有关
二进制位中，最左位决定正负
正数的原，反，补码均不变
负数的反码为符号位不变，每一位取反
负数的补码为该数绝对值取反再加1

实例：
85
原码：0000000001010101
反码：0000000001010101
补码：0000000001010101

-85
原码：1000000001010101
反码：1111111110101010
补码：1111111110101011

-144
原码：1000000010010000
反码：1111111101101111
补码：1111111101110000

负数补码的规律是该数绝对值取反再加1
综合-85及-144的补码，可以得到加1的规律为
1111111110101010+0000000000000001=1111111110101011
结尾为0直接变更为1
1111111101101111+0000000000000001=1111111101110000
当结尾为1时，加1会变为2
但二进制仅由0/1组成，无法出现0/1之外的数字
此时要应用逢二进一规则
即本位为2时，向前进一位1，同时本位归零

数据存放补码的原因
计算机处理器中是没有减法的处理，只是有加法的处理
在计算机中相关的减法运算都是加法模拟的
这一点直接说明了补码的重要性
好比如说，1-1
1      00000001
-1     10000001
1+(-1) 10000010
最终结果是-2，如果使用原码来进行运算

如果是补码
1      00000001
-1     11111111
1+(-1) 00000000
最终结果是0

如果要从更深层来说，可以这么讲
在计算机系统中，使用补码，可以将符号位和数值域统一处理
同时，加法和减法也可以统一处理
此外，补码和原码相互转换，其运算过程是相同的，不需要额外的硬件电路

小端存储和大端存储
数据存进内存中的方式有两种，小端存储（小端字节序）和大端存储（大端字节序）

大端存储是把数据的低位字节序的内容存放在高地址处，高位字节序的内容存放在低地址处
好比如说int类型
（低）[]  []  []  []  （高）//这是他的空间
要知道，地址中存放的是16进制数，4个二进制位可以表示1个16进制数
在32系统中，二进制位为32位，也就是8位16进制数
比起用32位来表示地址，明显0xdddddddd这种形式更加方便，x64自己推理一下
二进制存放的是bit，比特位，而1个字节由8个bit组成，int类型是4个字节
也就是说数据存进内存时，是这个样子的
[aa][bb][cc][dd]  //xx为16进制数，简单代表一下，不分大小，实际情况要区分大小
为了方便存放数据和使用数据，存储数据时会将首位（低位字节）放在低地址或高地址
其后其他16进制接着进入空间存储，形成有序的排布
VS采用小端存储，在小端存储的情况下，低位字节可以这么理解
00000000000000000000000000000000 32位，从右往左看，低位字节就是最右侧那8位

小端存储是把数据的低位字节序的内容存放在低地址处，高位字节序的内容存放在高地址处
VS采用小端存储

判断程序使用何种存储
#include <stdio.h>

int main()
{
	int i = 10;
	char* pi = (char*)&i;
	if (*pi == 10)
	{
		printf("小端\n");
	}
	else
	{
		printf("大端\n");
	}
	return 0;
}

整型在内存中存储的综合练习
signed与unsigned
#include <stdio.h>

int main()
{
	char a = -1;
	signed char b = -1;
	unsigned char c = -1;
	printf("%d %d %d", a, b, c);
	return 0;
}
输出结果为-1，-1，255
char a           11111111
signed char b    11111111
unsigned char c  11111111
char类型是一个字节，即8个bit，由于a，b，c的类型一样，赋值一样
最终存进内存中也是一样的，只是a，b，c的理解方式不同
二进制位首位是符号位，但是unsigned并不会认为这是符号位
在输出时，会发生整型提升，整型提升是按照符号位来提升的，无符号位补0
整型提升之后的二进制位
a 11111111111111111111111111111111
b 11111111111111111111111111111111
c 00000000000000000000000011111111
最终输出的结果是实质的数字，是原码
c的补码转换成原码后，为255的原码，这就是为何会输出255的结果

探讨unsigned int赋值负数
#include <stdio.h>

int main()
{
	unsigned int a = -1;
	printf("%d\n", a);
	printf("%u\n", a);
	return 0;
}
当一个负数赋值给unsigned int时，该值会被转化类型为无符号整数
这种类型转化基于补码，将其补码视为一个符号位并入计算的整数补码
有符号整型的二进制位最高位为符号位，决定正负
而unsigned int的最高位则是决定它的范围
当最高位为1时，它的数值范围为 0 到 4294967295（即(2 ^ {32} - 1）
当最高位不为0时，它的的范围为 0 到 2147483647，即(2 ^ {31} - 1）
实则是2 ^ {n} - 1  n为多少位为1二进制位
unsigned int赋值负数实则是根据无符号整型的最大值加1进行模运算
好比如说-2   实际应该为(2^{32}-1+1)+(-2)（别问为什么这么写）
在上述的例子中打印出现了截然不同的结果
%d和%u呈现了令人意外的结果，这是由于%d是用来打印有符号整数
就是说%d将a认为是有符号整型，此时a的值为4294967294
它的二进制位为32个1，在有符号整型中，这是-1的补码
%u则是打印无符号整型，可以将无符号整型的结果打印出来

内容补充-跃出范围整型提升
#include <stdio.h>

int main()
{
	char a = 128;
	printf("%u\n", a);
	return 0;
}
char的类型的变量在内存中分配一个字节，即8个bit
它的二进制范围为00000000到11111111
整型的二进制位应该有一位作为符号位，即最左一位
当二进制位为01111111时，取得最大值，为127
当二进制位10000001时，理应取得最小值-127
然而，如果选取作为最小值10000001[-127]，二进制位并没有被完全利用，这不合理
但是10000000有一个特别的问题，最左位是符号位，符号位不参与运算
这就意味着10000000无法进行补码向原码的转换，10000000无法得出有效结果
于是，计算机定义8位二进制10000000为-128
这样，可以直接得出char类型最小值应该为-128
因而，char类型的范围为-128到127
这是对于有符号的char类型来说的

回到题目，明显，128已经超出了char类型的范围
实际a的值为-128，这是因为范围是回环的
像时钟一样

     0
  -1   1
 -128
	127
然后，a发生整型提升，由于最终需要打印无符号整数
会对补码进行补0处理，然后基于补码运算
最终答案才会是4294967168
如果这是打印有符号整数，最终结果应该是-128

有符号整型与无符号整型的运算
#include <stdio.h>

int main()
{
	int i = -20;
	//11111111111111111111111111101100
	unsigned int j = 10;
	//00000000000000000000000000001010
	printf("%d\n", i+j);
	//i+j
	//11111111111111111111111111110110 补码
	//10000000000000000000000000001010 原码
	return 0;
}
使用二进制位来进行计算

超出阈值与char中的0
#include <stdio.h>
#include <string.h>

int main()
{
	char a[1000] = { 0 };
	int i = 0;
	for (i = 0; i < 1000; i++)
	{
		a[i] = -1 - i;
	}
	// -1 -2 -3 ... -128 127 ... 0 -1 -2 ... -128
	// 超出char范围的数字是这样变化的
	printf("%d", strlen(a));
	return 0;
}
ASCII表中的'\0'正好是0，当char等于0时程序就结束了

浮点数在内存中的存储
#include <stdio.h>

int main()
{
	int n = 9;
	float* pFloat = (float*)&n;
	printf("n的值为%d\n", n);
	printf("*pFloat的值为%f\n", *pFloat);
	//*pFloat这里是以浮点数的视角来看待，认为内存中存放的是浮点数

	*pFloat = 9.0;
	//以浮点数的视角存入9.0
	printf("n的值为%d\n", n);
	//以整型的形式拿出来
	printf("*pFloat的值为%f\n", *pFloat);
	return 0;
}
打印的结果为
n的值为9
*pFloat的值为0.000000
n的值为1091567616
*pFloat的值为9.000000
明显，以浮点数的视角来取出存在内存中的整数时，会产生非预期的结果
这充分说明了浮点数在内存中的存储方式以及解读方式不同于整型
为什么会产生这样的结果，你需要先学习浮点数的存储
（下面是一些特别难的内容，可以考虑跳过一整个浮点数章节）

浮点数如何在内存中存储
浮点数存储的标准是IEEE 754

根据IEEE 754标准，任意一个二进制浮点数V可以表示成以下形式
V=(-1)^S*M*2^E

(-1)^S表示符号位，当S=0时，V为正数，S=1，V为负数
M表示有效数字，大于等于1，小于2
2^E表示指数位
这里用5.5来进行举例子，5.5的二进制为101.1
2^0+2^1+2^2=5，2^-1=0.5，最终得出101.1
根据科学计数法，可以转换成1.011*2^2（移动两位）
可以类比10进制科学计数法的*10^n
1.011*2^2，这个表达方式，正是V=(-1)^S*M*2^E这种

正是因为这个标准，计算机凭借S,E,M就可以很好处理浮点数了
因而计算机在二进制位上进行了一定的分配处理
对于32位浮点数，最高位为S，紧接着8位是E，剩下的23位是M
对于64位浮点数，最高位为S，紧接着11位是E，剩下的52位是M

IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1
因此可以被舍去，只保存后面的xxxxx部分，比如保存1.01的时候
只保存01，等到读取的时候，再把第一位的1加上去
这样做的目的,是节省1位有效数字
以32位浮点数为例，留给M只有23位
将第一位的1舍去以后，等于可以保存24位有效数字

E为一个无符号整数(unsigned int)
如果E为8位,它的取值范围为0~255
如果E为11位,它的取值范围为0~`2047
但是，科学计数法中的E是可以出现负数的
所以IEEE 754规定,存入内存时E的真实值必须再加入一个中间数
对于8位的E，这个中间数是127，对于11位的E，这个中间数是1023
比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001

然后，指数E从内存中取出还可以分成三种情况
1.E不全为0或不全为1
这时，浮点数就采用下面的规则表示
指数E的计算值减去127(1023)，得到真实值，再将有效数字M前加上第一位的1

2.E全为0
这时，浮点数的指数E等于1-127(或者1-1023)，即为真实值
有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数
这样做是为了表示±0，以及接近于0的很小的数字

3.E全为1
这时，如果有效数字M全为0，表示+无穷大(正负取决于符号位s);

现在回到题目
#include <stdio.h>

int main()
{
	int n = 9;
	float* pFloat = (float*)&n;
	printf("n的值为%d\n", n);
	printf("*pFloat的值为%f\n", *pFloat);
	//*pFloat这里是以浮点数的视角来看待，认为内存中存放的是浮点数

	*pFloat = 9.0;
	//以浮点数的视角存入9.0
	printf("n的值为%d\n", n);
	//以整型的形式拿出来
	printf("*pFloat的值为%f\n", *pFloat);
	return 0;
}
9的二进制序列为00000000000000000000000000001001
以浮点数来看待的话，二进制为0 00000000 00000000000000000001001
明显，这是E为全0的情况，根据E为全0的情况
最终取出应该是0.00000000000000000001001*2^-126
因而第一个*pFloat最终输出结果为0.000000
当*pFloat = 9.0时，它的二进制为0 10000010 0010000000000000000000000
以整型的视角来看待的话，这就是一个超大的数字

内存分区及各功能
在内存中，有栈区，堆区，静态区，代码区
栈区中存放局部变量，函数的形参，临时变量
堆区是用来动态内存分配的
静态区用来存放全局变量，静态变量

memset 内存设置
void * memset ( void * ptr, int value, size_t num );
void * ptr 指向要填充的内存块的指针，void是无返回函数
int value 所用数据类型为int
size_t unsigned int 无符号int类型
作用是把指针ptr指向的内存块的前num个字节设置为指定的值
#include <stdio.h>
#include <string.h>

int main()
{
	char arr[] = "yinghuolight";
	memset(arr, 'x', 5);
	printf("%s", arr);
	return 0;
}
上述的结果是xxxxxuolight

//////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
实用调试技巧
调试的基本步骤
1.发现程序错误的存在
2.以隔离，消除等方式对错误进行定位
3.确定错误产生的原因
4.提出纠正错误的解决方法
5.予以改正，重新测试

Debug和Release的介绍
Debug通常被称为调试版本，它包含调试信息，并且不作任何优化，便于程序员调试程序
Release称为发布版本，它往往是进行了各种优化，使得程序在代码大小和运行速度都是最优的，以便用户的使用

Debug版本可以进行调试，按F5便会启动调试，而Release无法进行调试
值得注意的是，Debug版本运行没有问题不代表Release版本不会没有问题

在你调试之后，你可以右键解决方案，在资源管理器中打开文件夹，打开x86/x64文件夹
其中有Debug，Release文件夹，其中就有生成的exe
在之后你会接触生成dll等，而不仅仅是exe

windows环境调试介绍
调试环境准备（Debug）

学会快捷键
打开调试那一栏，你可以选择性记住这些快捷键
常见的有这些
F5 启动调试
F9 设置/取消断点，让程序在想要的地方停下来
F10 逐过程，每次处理一个过程
F11 逐语句，逐个语句执行，可以进入函数内部
CTRL+F5 不调试运行

写C++相关代码时，F9,F10,F11最为重要

调试时查看程序当前信息
调试窗口
在启动调试之后，你可以打开调试那一栏，选择窗口
其中有断点，监视，自动窗口，局部变量，调用堆栈，内存，反汇编，寄存器等
这些窗口对你的调试很有用

调用堆栈
用来反馈函数调用的逻辑

条件断点
你可以右键断点，就是左边那颗红点，选择条件
之后你可以在弹出的窗口上添加断点条件，方便调试

调试实例
#include <stdio.h>

int main()
{
	int i = 0;
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	for (i = 0; i <= 12; i++)
	{
		arr[i] = 0;
		printf("test\n");
	}
	return 0;
}
这一段代码是有问题的，已经越界访问了，运行的最终结果是13个test，然后崩溃
然而，有一种情况，如果这一段代码没有崩溃，那么最终结果会是无限循环的test
i=0  arr[0]=0
i=1  arr[1]=0
i=2  arr[2]=0
i=3  arr[3]=0
i=4  arr[4]=0
i=5  arr[5]=0
i=6  arr[6]=0
i=7  arr[7]=0
i=8  arr[8]=0
i=9  arr[9]=0
i=10  arr[10]=0
i=11  arr[11]=0   //越界访问，初始为随机数
i=12  arr[12]=12  //越界访问，初始为12
当i=12时，此时arr[12]=12，而不是随机数，这不符合常理
继续进行，arr[12]=0，然而，i也变成了0，这不符合常理
如果你有查看内存，你会发现arr[12]和i的地址是相同的
想要得到这种结果，你可以把你的编译环境改成x86

这是一种巧合吗？有一部分是巧合，还有一部分是原因
i和arr是局部变量，局部变量是放在栈区上的
栈区内存使用的习惯是先使用高地址空间，再使用低地址的空间
假设下面是栈区
[] 高地址
[] i
[] 11
[] 10
[] 9  arr...
[]
[]
[]
[]
[]
[]
[]
[]
[] 0  arr...
[]
[]
[]
[]
[]  低地址
数组随着下标的增长，地址是由低到高变化的
如果刚刚好arr[10]到i差两个空间
那么进行越界访问刚好会覆盖掉i的内存空间

如何写出好的代码
使用coding技巧
1.使用assert
2.尽量使用const
3.养成良好的代码风格
4.添加必要的注释
5.避免编码的陷阱

实例:模拟实现strcpy
#include <stdio.h>

版本1
void my_strcpy(char* dest, char* src)
{
	while (*src != '\0')
	{
		*dest++ = *src++;
	}
	*dest = *src;
}

版本2
void my_strcpy(char* dest, char* src)
{
	while (*dest++ = *src++)
	{
		;
	}
}

int main()
{
	char arr1[20] = "xxxxxxxx";
	char arr2[] = "hello";  //strcpy会复制\0
	my_strcpy(arr1, arr2);
	printf("%s", arr1);
	return 0;
}

更多的优化
考虑空指针（空指针无法被解引用）
#include <stdio.h>
#include <assert.h>

void my_strcpy(char* dest, char* src)
{
	assert(src != NULL);
	assert(dest != NULL);
	//assert断言，判断条件是否为真，若不为真，则报错
	while (*dest++ = *src++)
	{
		;
	}
}

int main()
{
	char arr1[20] = "xxxxxxxx";
	char arr2[] = "hello";  //strcpy会复制\0
	my_strcpy(arr1, NULL);
	printf("%s", arr1);
	return 0;
}

加入const
#include <stdio.h>

void my_strcpy(char* dest, const char* src)  //const能够保护src不被修改
{
	while (*src++ = *dest++)  //这里写反了，正常用要改回来
	{
		;
	}
}

int main()
{
	char arr1[20] = "xxxxxxxx";
	char arr2[] = "hello";
	my_strcpy(arr1, arr2);
	printf("%s", arr1);
	return 0;
}
arr1和arr2的空间大小不同，不能够互换位置，会造成越界
表达式左边不能指定const对象，const指针src所指向的内容是无法被修改的
但是指针本身能够被修改，加深理解可以去看const那篇

返回类型为char *
根据定义，strcpy这个库函数其实返回的是目标空间的起始地址
#include <stdio.h>

char* my_strcpy(char* dest, const char* src)
{
	char* ret = dest;
	while (*dest++ = *src++)
	{
		;
	}
	return ret;
}

int main()
{
	char arr1[20] = "xxxxxxxx";
	char arr2[] = "hello";
	printf("%s", my_strcpy(arr1, arr2));  //链式访问
	return 0;
}

strlen函数，求字符段长度
#include <stdio.h>
#include <assert.h>

int my_strlen(const char* str)
{
	assert(str != NULL);
	int count = 0;
	while (*str != '\0')
	{
		count++;
		str++;
	}
	return count;
}

int main()
{
	char arr[] = { "yhlight" };
	//char arr[] = { NULL };
	printf("%d", my_strlen(arr));
	return 0;
}

编程中常见的错误
编译型错误
直接看错误提示信息，双击可跳转到问题所在，凭借自己的经验来解决

链接型错误
看错误提示信息，主要是在代码中找到错误信息中的标识符
然后定位问题所在，一般是标识符不存在或者拼写错误

运行时错误
借助调试，逐步定位问题

//////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////
const 不变的
const修饰变量
由const修饰的变量，不能被修改
这些被修饰的变量称为常变量，但是本质上还是变量

危险操作-指针更改
#include <stdio.h>

int main()
{
	const int num = 10;
	int* p = &num;
	*p = 20;
	printf("%d\n", num);
	return 0;
}
违背了const的初衷，不应该能修改

const修饰指针
#include <stdio.h>

int main()
{
	const int num = 10;
	const int a = 20;
	const int* p = &num;
	p = &a;
	printf("%d\n", num);
	return 0;
}
当const修饰指针时，指针所指向的内容无法被更改
但是指针本身能够被修改

const修饰指针变量
#include <stdio.h>

int main()
{
	const int num = 10;
	int* const p = &num;
	*p = 20;
	printf("%d\n", num);
	return 0;
}
当const修饰指针变量时，修饰的是指针变量p，表示指针变量不能被改变
但是指针指向的内容，可以被改变

const修饰指针和指针变量
#include <stdio.h>

int main()
{
	const int num = 10;
	int const* const p = &num;  //等价于const int* const p = &num;
	printf("%d\n", num);
	return 0;
}
这回锁死了，不上二级指针是改不了了

//////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
class101C语言初阶考试
1.求最小公倍数 时间限制：1秒 内存限制32768k
#include <stdio.h>

int main()
{
	int a = 0;
	int b = 0;
	scanf("%d %d", &a, & b);
	int min = a > b ? a : b;
	while (1)
	{
		if (min % a == 0 && min % b == 0)
		{
			printf("%d\n", min);
			break;
		}
		min++;
	}
	return 0;
}

第二种
#include <stdio.h>

int main()
{
	int a = 0;
	int b = 0;
	scanf("%d %d", &a, & b);
	int i = 1;
	for (i = 1;; i++)
	{
		if ((a * i) % b == 0)
		{
			printf("%d", a * i);
			break;
		}
	}
	return 0;
}

第三种
#include <stdio.h>

int gcd(int a, int b) 
{
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

int lcm(int a, int b) 
{
    return (a * b) / gcd(a, b);
}

int main()
{
    int num1 = 0;
    int num2 = 0;
    scanf("%d %d", &num1, &num2);
    int ret1 = gcd(num1, num2);
    int ret2 = lcm(num1, num2);
    printf("%d", ret2);
    return 0;
}

2.将一句话的单词倒置，标点不倒置
#include <stdio.h>
#include <string.h>

void reverse(char* left, char* right)
{
	while (left < right)
	{
		char tmp = 0;
		tmp = *left;
		*left = *right;
		*right = tmp;
		left++;
		right--;
	}
}

int main()
{
	char arr[100] = { 0 };
	gets(arr);
	int len = strlen(arr);
	reverse(arr, arr + len - 1);
	char* start = arr;
	while (*start)
	{
		char* end = start;
		while (*end != ' ' && *end != '\0')
		{
			end++;
		}
		reverse(start, end - 1);
		if (*end == ' ')
		{
			start = end + 1;
		}
		else
		{
			start = end;
		}
	}
	printf("%s", arr);
	return 0;
}

//////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////
指针（进阶）
1.字符指针
字符指针的用法
1.单字符
#include <stdio.h>

int main()
{
	char ch = 'w';
	char* pc = &ch;
	return 0;
}

2.字符串
#include <stdio.h>

int main()
{
	char* py = "yhlight";
	return 0;
}
存放的是字符串的首位地址
注意，不要认为这等同于数组

笔试题
#include <stdio.h>

int main()
{
	char str1[] = "hello bit.";
	char str2[] = "hello bit.";
	char* str3 = "hello bit.";
	char* str4 = "hello bit.";
	if (str1 == str2)
	{
		printf("same\n");
	}
	else
	{
		printf("not same\n");
	}
	if (str3 == str4)
	{
		printf("same\n");
	}
	else
	{
		printf("not same\n");
	}
	return 0;
}
这道题要注意的是str1 == str2，并不是因为字符串比较需要用strcmp函数
这里的str1 == str2是指地址，不要直接当成字符串比较需要用strcmp函数就直接ban掉了
str1，str2，str3，str4存放的都是这个字符串首字符的地址
不同的是，str3，str4存储的"hello bit."这个字符串，它是一个常量字符串
就是说，它不能被更改，你无法用解引用来更改（别tm觉得能解引用就tm认为这是能用的）
正是因为无法被更改，有一些编译器选择使用相同的空间来存放，而不创建新的空间
注意，请使用const char* str3 = "hello bit."; 以防出现报错

2.指针数组（没啥可讲）
#include <stdio.h>

int main()
{
	int a[] = { 1,2,3,4,5 };
	int b[] = { 2,3,4,5,6 };
	int c[] = { 3,4,5,6,7 };
	int* arr[3] = { a,b,c };
	int i = 0;
	for (i = 0; i < 3; i++)
	{
		int j = 0;
		for (j = 0; j < 5; j++)
		{
			printf("%d ", *(arr[i] + j));
			//可以等价printf("%d ", arr[i][j]);
		}
		printf("\n");
	}
	return 0;
}
（真没啥可以解析，看不懂那是你问题，这玩意都说不上新内容）
数组名是数组首元素的地址，int* arr[3] = { a,b,c };实则是存进了三个数组的首元素地址
再经过上述一系列的操作可以得出一个伪二维数组

3.数组指针
#include <stdio.h>

int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int (*parr)[10] = &arr;  //取的是数组的地址
	return 0;
}
这是一个简单的数组指针

&数组名和数组名的区别
#include <stdio.h>

int main()
{
	int arr[10] = { 0 };
	int* p1 = arr;
	int (*p2)[10] = &arr;
	printf("%p\n", arr);
	printf("%p\n", &arr);

	printf("%p\n", p1);
	printf("%p\n", p2);
	printf("%p\n", p1 + 1);
	printf("%p\n", p2 + 1);
	return 0;
}
通过上面的代码可以看到，它们的地址是相同的
似乎两者并没有什么区别，然而，它们所要表达的意义是完全不一样
数组名是数组首元素地址，而&数组名则是取整个数组的地址
由于两者都是指向首元素，所以它们打印出来的地址是一样的
然而，它们的类型是不一样的，这决定了它们表达的意义是不同的

arr是一个int类型的数组，p1是int类型的指针，而p2是int类型的数组指针
当你进行p1+1时，由于是int类型的指针，它会跳过4或8个字节
而当你进行p2+1时，则会跳过40或80个字节
这是因为它是一个int类型且有10个元素的数组指针
因而，结论为，&arr表示的是数组的地址，而不是数组首元素的地址

注意！数组名是数组首元素的地址这个结论有两个例外
1.sizeof(数组名) - 计算的是整个数组的大小，单位是字节
2.&数组名 - 取得是整个数组的地址

数组指针在二维数组中的使用（一维数组会去世）
#include <stdio.h>

void print1(int arr[3][5], int r, int c)
{
	int i = 0;
	int j = 0;
	for (i = 0; i < r; i++)
	{
		for (j = 0; j < c; j++)
		{
			printf("%d ", arr[i][j]);
		}
		printf("\n");
	}
}

void print2(int (*p)[5], int r, int c)
{
	int i = 0;
	int j = 0;
	for (i = 0; i < r; i++)
	{
		for (j = 0; j < c; j++)
		{
			printf("%d ", *(*(p + i) + j));
		}
		printf("\n");
	}
}

int main()
{
	int arr[3][5] = { {1,2,3,4,5},{2,3,4,5,6},{3,4,5,6,7} };
	print1(arr, 3, 5);
	print2(arr, 3, 5);
	return 0;
}
解读一下代码里面一些复杂的内容
int (*p)[5]，这是一个一维数组指针，用来充当二维数组的行

*(*(p + i) + j)，这个要进行一定的拆分
p + i，p是数组指针，p+i表示跳过i个数组的字节，也就是到了二维数组的第i行
*(p + i)，p+i后，来到了第二行的首位，对p+i进行解引用可以得到相应的元素
也就是得到指针，换而言之，就是得到了相应位的地址
得到了地址后，对指针进行+j可以来到第j位元素的位置
*(*(p + i) + j)，再对其整个整体进行解引用就可以得到相应的元素了

指针数组，数组指针，一些常例分析
int arr[5];  //只是一个简单的数组

int* parr1[10];  //指针数组

int (*parr2)[10];  //数组指针

int (*parr3[10])[5];  //数组指针数组
parr3是一个存储数组指针的数组，该数组能够存放10个数组指针
每个数组指针能够指向一个数组，数组5个元素，每个元素是int类型

4.数组传参和指针传参
一维数组传参
#include <stdio.h>

void test(int arr[])  //正确
{}

void test(int arr[10])  //正确
{}

void test(int *arr)  //正确
{}

void test2(int *arr[20])  //正确
{}

void test2(int **arr)  //正确
{}

int mian()
{
	int arr[10] = { 0 };
	int* arr2[20] = { 0 };
	test(arr);
	test2(arr2);
}
以上出现的写法均为正确写法，其他写法需要自行辨别

二维数组传参
#include <stdio.h>

void test(int arr[3][5])  //正确
{}

void test(int arr[][])  //不正确，最多省略行，不得省略列
{}

void test(int arr[][5])  //正确
{}

void test(int *arr)  //不正确
{}

void test(int* arr[5])  //不正确
{}

void test(int (*arr)[5])  //正确
{}

void test(int** arr)  //不正确
{}

int mian()
{
	int arr[3][5] = { 0 };
	test(arr);
}

5.函数指针

6.函数指针数组

//////////////////////////////////////////////////////////////